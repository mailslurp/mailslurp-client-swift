//
// SmsControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import PromiseKit
#if canImport(AnyCodable)
import AnyCodable
#endif

@objcMembers open class SmsControllerAPI : NSObject {

    /**
     Delete sent SMS message.
     
     - parameter sentSmsId: (path)  
     - returns: Promise<Void>
     */
    open class func deleteSentSmsMessage( sentSmsId: UUID) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSentSmsMessageWithRequestBuilder(sentSmsId: sentSmsId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete sent SMS message.
     - DELETE /sms/sent/{sentSmsId}
     - Delete a sent SMS message
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter sentSmsId: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSentSmsMessageWithRequestBuilder(sentSmsId: UUID) -> RequestBuilder<Void> {
        var localVariablePath = "/sms/sent/{sentSmsId}"
        let sentSmsIdPreEscape = "\(APIHelper.mapValueToPathItem(sentSmsId))"
        let sentSmsIdPostEscape = sentSmsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{sentSmsId}", with: sentSmsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete all sent SMS messages
     
     - parameter phoneNumberId: (query)  (optional)
     - returns: Promise<Void>
     */
    open class func deleteSentSmsMessages( phoneNumberId: UUID? = nil) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSentSmsMessagesWithRequestBuilder(phoneNumberId: phoneNumberId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all sent SMS messages
     - DELETE /sms/sent
     - Delete all sent SMS messages or all messages for a given phone number
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumberId: (query)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSentSmsMessagesWithRequestBuilder(phoneNumberId: UUID? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/sms/sent"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumberId": (wrappedValue: phoneNumberId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete SMS message.
     
     - parameter smsId: (path)  
     - returns: Promise<Void>
     */
    open class func deleteSmsMessage( smsId: UUID) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete SMS message.
     - DELETE /sms/{smsId}
     - Delete an SMS message
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<Void> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Delete all SMS messages
     
     - parameter phoneNumberId: (query)  (optional)
     - returns: Promise<Void>
     */
    open class func deleteSmsMessages( phoneNumberId: UUID? = nil) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessagesWithRequestBuilder(phoneNumberId: phoneNumberId).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all SMS messages
     - DELETE /sms
     - Delete all SMS messages or all messages for a given phone number
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumberId: (query)  (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessagesWithRequestBuilder(phoneNumberId: UUID? = nil) -> RequestBuilder<Void> {
        let localVariablePath = "/sms"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumberId": (wrappedValue: phoneNumberId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllSmsMessages: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**

     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter favourite: (query) Optionally filter results for favourites only (optional, default to false)
     - returns: Promise<PageSmsProjection>
     */
    open class func getAllSmsMessages( phoneNumber: UUID? = nil,  page: Int? = nil,  size: Int? = nil,  sort: Sort_getAllSmsMessages? = nil,  since: Date? = nil,  before: Date? = nil,  search: String? = nil,  favourite: Bool? = nil) -> Promise<PageSmsProjection> {
        let deferred = Promise<PageSmsProjection>.pending()
        getAllSmsMessagesWithRequestBuilder(phoneNumber: phoneNumber, page: page, size: size, sort: sort, since: since, before: before, search: search, favourite: favourite).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /sms
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter favourite: (query) Optionally filter results for favourites only (optional, default to false)
     - returns: RequestBuilder<PageSmsProjection> 
     */
    open class func getAllSmsMessagesWithRequestBuilder(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getAllSmsMessages? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil, favourite: Bool? = nil) -> RequestBuilder<PageSmsProjection> {
        let localVariablePath = "/sms"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumber": (wrappedValue: phoneNumber?.encodeToJSON(), isExplode: true),
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "size": (wrappedValue: size?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "since": (wrappedValue: since?.encodeToJSON(), isExplode: true),
            "before": (wrappedValue: before?.encodeToJSON(), isExplode: true),
            "search": (wrappedValue: search?.encodeToJSON(), isExplode: true),
            "favourite": (wrappedValue: favourite?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageSmsProjection>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get reply for an SMS message
     
     - parameter smsId: (path)  
     - returns: Promise<ReplyForSms>
     */
    open class func getReplyForSmsMessage( smsId: UUID) -> Promise<ReplyForSms> {
        let deferred = Promise<ReplyForSms>.pending()
        getReplyForSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get reply for an SMS message
     - GET /sms/{smsId}/reply
     - Get reply for an SMS message.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<ReplyForSms> 
     */
    open class func getReplyForSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<ReplyForSms> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ReplyForSms>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get sent SMS count
     
     - returns: Promise<CountDto>
     */
    open class func getSentSmsCount() -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getSentSmsCountWithRequestBuilder().execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get sent SMS count
     - GET /sms/sent/count
     - Get number of sent SMS
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - returns: RequestBuilder<CountDto> 
     */
    open class func getSentSmsCountWithRequestBuilder() -> RequestBuilder<CountDto> {
        let localVariablePath = "/sms/sent/count"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get sent SMS content including body. Expects sent SMS to exist by ID.
     
     - parameter sentSmsId: (path)  
     - returns: Promise<SentSmsDto>
     */
    open class func getSentSmsMessage( sentSmsId: UUID) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        getSentSmsMessageWithRequestBuilder(sentSmsId: sentSmsId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get sent SMS content including body. Expects sent SMS to exist by ID.
     - GET /sms/sent/{sentSmsId}
     - Returns an SMS summary object with content.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter sentSmsId: (path)  
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func getSentSmsMessageWithRequestBuilder(sentSmsId: UUID) -> RequestBuilder<SentSmsDto> {
        var localVariablePath = "/sms/sent/{sentSmsId}"
        let sentSmsIdPreEscape = "\(APIHelper.mapValueToPathItem(sentSmsId))"
        let sentSmsIdPostEscape = sentSmsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{sentSmsId}", with: sentSmsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getSentSmsMessagesPaginated: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     
     - parameter phoneNumber: (query) Optional phone number to filter sent SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - returns: Promise<PageSentSmsProjection>
     */
    open class func getSentSmsMessagesPaginated( phoneNumber: UUID? = nil,  page: Int? = nil,  size: Int? = nil,  sort: Sort_getSentSmsMessagesPaginated? = nil,  since: Date? = nil,  before: Date? = nil,  search: String? = nil) -> Promise<PageSentSmsProjection> {
        let deferred = Promise<PageSentSmsProjection>.pending()
        getSentSmsMessagesPaginatedWithRequestBuilder(phoneNumber: phoneNumber, page: page, size: size, sort: sort, since: since, before: before, search: search).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     - GET /sms/sent
     - By default returns all SMS messages across all phone numbers sorted by ascending created at date. Responses are paginated. You can restrict results to a list of phone number IDs. You can also filter out read messages
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumber: (query) Optional phone number to filter sent SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - returns: RequestBuilder<PageSentSmsProjection> 
     */
    open class func getSentSmsMessagesPaginatedWithRequestBuilder(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getSentSmsMessagesPaginated? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil) -> RequestBuilder<PageSentSmsProjection> {
        let localVariablePath = "/sms/sent"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumber": (wrappedValue: phoneNumber?.encodeToJSON(), isExplode: true),
            "page": (wrappedValue: page?.encodeToJSON(), isExplode: true),
            "size": (wrappedValue: size?.encodeToJSON(), isExplode: true),
            "sort": (wrappedValue: sort?.encodeToJSON(), isExplode: true),
            "since": (wrappedValue: since?.encodeToJSON(), isExplode: true),
            "before": (wrappedValue: before?.encodeToJSON(), isExplode: true),
            "search": (wrappedValue: search?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageSentSmsProjection>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get SMS count
     
     - returns: Promise<CountDto>
     */
    open class func getSmsCount() -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getSmsCountWithRequestBuilder().execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS count
     - GET /sms/count
     - Get number of SMS
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - returns: RequestBuilder<CountDto> 
     */
    open class func getSmsCountWithRequestBuilder() -> RequestBuilder<CountDto> {
        let localVariablePath = "/sms/count"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     
     - parameter smsId: (path)  
     - returns: Promise<SmsDto>
     */
    open class func getSmsMessage( smsId: UUID) -> Promise<SmsDto> {
        let deferred = Promise<SmsDto>.pending()
        getSmsMessageWithRequestBuilder(smsId: smsId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     - GET /sms/{smsId}
     - Returns a SMS summary object with content.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - returns: RequestBuilder<SmsDto> 
     */
    open class func getSmsMessageWithRequestBuilder(smsId: UUID) -> RequestBuilder<SmsDto> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Get unread SMS count
     
     - returns: Promise<UnreadCount>
     */
    open class func getUnreadSmsCount() -> Promise<UnreadCount> {
        let deferred = Promise<UnreadCount>.pending()
        getUnreadSmsCountWithRequestBuilder().execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get unread SMS count
     - GET /sms/unreadCount
     - Get number of SMS unread. Unread means has not been viewed in dashboard or returned in an email API response
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - returns: RequestBuilder<UnreadCount> 
     */
    open class func getUnreadSmsCountWithRequestBuilder() -> RequestBuilder<UnreadCount> {
        let localVariablePath = "/sms/unreadCount"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UnreadCount>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - returns: Promise<SentSmsDto>
     */
    open class func replyToSmsMessage( smsId: UUID,  smsReplyOptions: SmsReplyOptions) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        replyToSmsMessageWithRequestBuilder(smsId: smsId, smsReplyOptions: smsReplyOptions).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     - POST /sms/{smsId}/reply
     - Reply to an SMS message.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func replyToSmsMessageWithRequestBuilder(smsId: UUID, smsReplyOptions: SmsReplyOptions) -> RequestBuilder<SentSmsDto> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: smsReplyOptions)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**

     - parameter smsSendOptions: (body)  
     - parameter fromPhoneNumber: (query) Phone number to send from in E.164 format (optional)
     - parameter fromPhoneId: (query) Phone number ID to send from in UUID form (optional)
     - returns: Promise<SentSmsDto>
     */
    open class func sendSms( smsSendOptions: SmsSendOptions,  fromPhoneNumber: String? = nil,  fromPhoneId: UUID? = nil) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        sendSmsWithRequestBuilder(smsSendOptions: smsSendOptions, fromPhoneNumber: fromPhoneNumber, fromPhoneId: fromPhoneId).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - POST /sms/send
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsSendOptions: (body)  
     - parameter fromPhoneNumber: (query) Phone number to send from in E.164 format (optional)
     - parameter fromPhoneId: (query) Phone number ID to send from in UUID form (optional)
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func sendSmsWithRequestBuilder(smsSendOptions: SmsSendOptions, fromPhoneNumber: String? = nil, fromPhoneId: UUID? = nil) -> RequestBuilder<SentSmsDto> {
        let localVariablePath = "/sms/send"
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: smsSendOptions)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fromPhoneNumber": (wrappedValue: fromPhoneNumber?.encodeToJSON(), isExplode: true),
            "fromPhoneId": (wrappedValue: fromPhoneId?.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }

    /**

     - parameter smsId: (path) ID of SMS to set favourite state 
     - parameter favourited: (query)  
     - returns: Promise<SmsDto>
     */
    open class func setSmsFavourited( smsId: UUID,  favourited: Bool) -> Promise<SmsDto> {
        let deferred = Promise<SmsDto>.pending()
        setSmsFavouritedWithRequestBuilder(smsId: smsId, favourited: favourited).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - PUT /sms/{smsId}/favourite
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path) ID of SMS to set favourite state 
     - parameter favourited: (query)  
     - returns: RequestBuilder<SmsDto> 
     */
    open class func setSmsFavouritedWithRequestBuilder(smsId: UUID, favourited: Bool) -> RequestBuilder<SmsDto> {
        var localVariablePath = "/sms/{smsId}/favourite"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = mailslurpAPI.basePath + localVariablePath
        let localVariableParameters: [String: Any]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "favourited": (wrappedValue: favourited.encodeToJSON(), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: Any?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SmsDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true)
    }
}
