//
// SmsControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
@preconcurrency import PromiseKit

@objcMembers open class SmsControllerAPI : NSObject {

    /**
     Delete sent SMS message.
     
     - parameter sentSmsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteSentSmsMessage(sentSmsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSentSmsMessageWithRequestBuilder(sentSmsId: sentSmsId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete sent SMS message.
     - DELETE /sms/sent/{sentSmsId}
     - Delete a sent SMS message
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter sentSmsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSentSmsMessageWithRequestBuilder(sentSmsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/sms/sent/{sentSmsId}"
        let sentSmsIdPreEscape = "\(APIHelper.mapValueToPathItem(sentSmsId))"
        let sentSmsIdPostEscape = sentSmsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{sentSmsId}", with: sentSmsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete all sent SMS messages
     
     - parameter phoneNumberId: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteSentSmsMessages(phoneNumberId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSentSmsMessagesWithRequestBuilder(phoneNumberId: phoneNumberId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all sent SMS messages
     - DELETE /sms/sent
     - Delete all sent SMS messages or all messages for a given phone number
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumberId: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSentSmsMessagesWithRequestBuilder(phoneNumberId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/sms/sent"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumberId": (wrappedValue: phoneNumberId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete SMS message.
     
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteSmsMessage(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessageWithRequestBuilder(smsId: smsId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete SMS message.
     - DELETE /sms/{smsId}
     - Delete an SMS message
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessageWithRequestBuilder(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete all SMS messages
     
     - parameter phoneNumberId: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteSmsMessages(phoneNumberId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteSmsMessagesWithRequestBuilder(phoneNumberId: phoneNumberId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all SMS messages
     - DELETE /sms
     - Delete all SMS messages or all messages for a given phone number
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumberId: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteSmsMessagesWithRequestBuilder(phoneNumberId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/sms"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumberId": (wrappedValue: phoneNumberId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllSmsMessages: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**

     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter favourite: (query) Optionally filter results for favourites only (optional, default to false)
     - parameter include: (query) Optional list of IDs to include in result (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageSmsProjection>
     */
    open class func getAllSmsMessages(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getAllSmsMessages? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil, favourite: Bool? = nil, include: [UUID]? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageSmsProjection> {
        let deferred = Promise<PageSmsProjection>.pending()
        getAllSmsMessagesWithRequestBuilder(phoneNumber: phoneNumber, page: page, size: size, sort: sort, since: since, before: before, search: search, favourite: favourite, include: include, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /sms
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumber: (query) Optional receiving phone number to filter SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter favourite: (query) Optionally filter results for favourites only (optional, default to false)
     - parameter include: (query) Optional list of IDs to include in result (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageSmsProjection> 
     */
    open class func getAllSmsMessagesWithRequestBuilder(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getAllSmsMessages? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil, favourite: Bool? = nil, include: [UUID]? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageSmsProjection> {
        let localVariablePath = "/sms"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumber": (wrappedValue: phoneNumber?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "search": (wrappedValue: search?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "favourite": (wrappedValue: favourite?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "include": (wrappedValue: include?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageSmsProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get reply for an SMS message
     
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ReplyForSms>
     */
    open class func getReplyForSmsMessage(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ReplyForSms> {
        let deferred = Promise<ReplyForSms>.pending()
        getReplyForSmsMessageWithRequestBuilder(smsId: smsId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get reply for an SMS message
     - GET /sms/{smsId}/reply
     - Get reply for an SMS message.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ReplyForSms> 
     */
    open class func getReplyForSmsMessageWithRequestBuilder(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ReplyForSms> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ReplyForSms>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get sent SMS count
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<CountDto>
     */
    open class func getSentSmsCount(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getSentSmsCountWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get sent SMS count
     - GET /sms/sent/count
     - Get number of sent SMS
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<CountDto> 
     */
    open class func getSentSmsCountWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<CountDto> {
        let localVariablePath = "/sms/sent/count"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get sent SMS content including body. Expects sent SMS to exist by ID.
     
     - parameter sentSmsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SentSmsDto>
     */
    open class func getSentSmsMessage(sentSmsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        getSentSmsMessageWithRequestBuilder(sentSmsId: sentSmsId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get sent SMS content including body. Expects sent SMS to exist by ID.
     - GET /sms/sent/{sentSmsId}
     - Returns an SMS summary object with content.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter sentSmsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func getSentSmsMessageWithRequestBuilder(sentSmsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SentSmsDto> {
        var localVariablePath = "/sms/sent/{sentSmsId}"
        let sentSmsIdPreEscape = "\(APIHelper.mapValueToPathItem(sentSmsId))"
        let sentSmsIdPostEscape = sentSmsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{sentSmsId}", with: sentSmsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getSentSmsMessagesPaginated: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     
     - parameter phoneNumber: (query) Optional phone number to filter sent SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageSentSmsProjection>
     */
    open class func getSentSmsMessagesPaginated(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getSentSmsMessagesPaginated? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageSentSmsProjection> {
        let deferred = Promise<PageSentSmsProjection>.pending()
        getSentSmsMessagesPaginatedWithRequestBuilder(phoneNumber: phoneNumber, page: page, size: size, sort: sort, since: since, before: before, search: search, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all SMS messages in all phone numbers in paginated form. .
     - GET /sms/sent
     - By default returns all SMS messages across all phone numbers sorted by ascending created at date. Responses are paginated. You can restrict results to a list of phone number IDs. You can also filter out read messages
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumber: (query) Optional phone number to filter sent SMS messages for (optional)
     - parameter page: (query) Optional page index in SMS list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in SMS list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Optional filter SMSs received after given date time (optional)
     - parameter before: (query) Optional filter SMSs received before given date time (optional)
     - parameter search: (query) Optional search filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageSentSmsProjection> 
     */
    open class func getSentSmsMessagesPaginatedWithRequestBuilder(phoneNumber: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getSentSmsMessagesPaginated? = nil, since: Date? = nil, before: Date? = nil, search: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageSentSmsProjection> {
        let localVariablePath = "/sms/sent"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "phoneNumber": (wrappedValue: phoneNumber?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "search": (wrappedValue: search?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageSentSmsProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get SMS count
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<CountDto>
     */
    open class func getSmsCount(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getSmsCountWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS count
     - GET /sms/count
     - Get number of SMS
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<CountDto> 
     */
    open class func getSmsCountWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<CountDto> {
        let localVariablePath = "/sms/count"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SmsDto>
     */
    open class func getSmsMessage(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SmsDto> {
        let deferred = Promise<SmsDto>.pending()
        getSmsMessageWithRequestBuilder(smsId: smsId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMS content including body. Expects SMS to exist by ID. For SMS that may not have arrived yet use the WaitForController.
     - GET /sms/{smsId}
     - Returns a SMS summary object with content.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SmsDto> 
     */
    open class func getSmsMessageWithRequestBuilder(smsId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SmsDto> {
        var localVariablePath = "/sms/{smsId}"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SmsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get unread SMS count
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<UnreadCount>
     */
    open class func getUnreadSmsCount(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<UnreadCount> {
        let deferred = Promise<UnreadCount>.pending()
        getUnreadSmsCountWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get unread SMS count
     - GET /sms/unreadCount
     - Get number of SMS unread. Unread means has not been viewed in dashboard or returned in an email API response
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<UnreadCount> 
     */
    open class func getUnreadSmsCountWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<UnreadCount> {
        let localVariablePath = "/sms/unreadCount"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UnreadCount>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SentSmsDto>
     */
    open class func replyToSmsMessage(smsId: UUID, smsReplyOptions: SmsReplyOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        replyToSmsMessageWithRequestBuilder(smsId: smsId, smsReplyOptions: smsReplyOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send a reply to a received SMS message. Replies are sent from the receiving number.
     - POST /sms/{smsId}/reply
     - Reply to an SMS message.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path)  
     - parameter smsReplyOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func replyToSmsMessageWithRequestBuilder(smsId: UUID, smsReplyOptions: SmsReplyOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SentSmsDto> {
        var localVariablePath = "/sms/{smsId}/reply"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: smsReplyOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter smsSendOptions: (body)  
     - parameter fromPhoneNumber: (query) Phone number to send from in E.164 format (optional)
     - parameter fromPhoneId: (query) Phone number ID to send from in UUID form (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SentSmsDto>
     */
    open class func sendSms(smsSendOptions: SmsSendOptions, fromPhoneNumber: String? = nil, fromPhoneId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SentSmsDto> {
        let deferred = Promise<SentSmsDto>.pending()
        sendSmsWithRequestBuilder(smsSendOptions: smsSendOptions, fromPhoneNumber: fromPhoneNumber, fromPhoneId: fromPhoneId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - POST /sms/send
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsSendOptions: (body)  
     - parameter fromPhoneNumber: (query) Phone number to send from in E.164 format (optional)
     - parameter fromPhoneId: (query) Phone number ID to send from in UUID form (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SentSmsDto> 
     */
    open class func sendSmsWithRequestBuilder(smsSendOptions: SmsSendOptions, fromPhoneNumber: String? = nil, fromPhoneId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SentSmsDto> {
        let localVariablePath = "/sms/send"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: smsSendOptions, codableHelper: apiConfiguration.codableHelper)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "fromPhoneNumber": (wrappedValue: fromPhoneNumber?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "fromPhoneId": (wrappedValue: fromPhoneId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentSmsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter smsId: (path) ID of SMS to set favourite state 
     - parameter favourited: (query)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SmsDto>
     */
    open class func setSmsFavourited(smsId: UUID, favourited: Bool, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SmsDto> {
        let deferred = Promise<SmsDto>.pending()
        setSmsFavouritedWithRequestBuilder(smsId: smsId, favourited: favourited, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - PUT /sms/{smsId}/favourite
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter smsId: (path) ID of SMS to set favourite state 
     - parameter favourited: (query)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SmsDto> 
     */
    open class func setSmsFavouritedWithRequestBuilder(smsId: UUID, favourited: Bool, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SmsDto> {
        var localVariablePath = "/sms/{smsId}/favourite"
        let smsIdPreEscape = "\(APIHelper.mapValueToPathItem(smsId))"
        let smsIdPostEscape = smsIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{smsId}", with: smsIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "favourited": (wrappedValue: favourited.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SmsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }
}
