//
// CommonActionsControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
@preconcurrency import PromiseKit

@objcMembers open class CommonActionsControllerAPI : NSObject {

    /**
     * enum for parameter inboxType
     */
    public enum InboxType_createNewEmailAddress: String, Sendable, CaseIterable {
        case httpInbox = "HTTP_INBOX"
        case smtpInbox = "SMTP_INBOX"
    }

    /**
     Create new random inbox
     
     - parameter allowTeamAccess: (query)  (optional)
     - parameter useDomainPool: (query)  (optional)
     - parameter expiresAt: (query)  (optional)
     - parameter expiresIn: (query)  (optional)
     - parameter emailAddress: (query)  (optional)
     - parameter inboxType: (query)  (optional)
     - parameter _description: (query)  (optional)
     - parameter name: (query)  (optional)
     - parameter tags: (query)  (optional)
     - parameter favourite: (query)  (optional)
     - parameter virtualInbox: (query)  (optional)
     - parameter useShortAddress: (query)  (optional)
     - parameter domainName: (query)  (optional)
     - parameter domainId: (query)  (optional)
     - parameter _prefix: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<InboxDto>
     */
    open class func createNewEmailAddress(allowTeamAccess: Bool? = nil, useDomainPool: Bool? = nil, expiresAt: Date? = nil, expiresIn: Int64? = nil, emailAddress: String? = nil, inboxType: InboxType_createNewEmailAddress? = nil, _description: String? = nil, name: String? = nil, tags: [String]? = nil, favourite: Bool? = nil, virtualInbox: Bool? = nil, useShortAddress: Bool? = nil, domainName: String? = nil, domainId: UUID? = nil, _prefix: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<InboxDto> {
        let deferred = Promise<InboxDto>.pending()
        createNewEmailAddressWithRequestBuilder(allowTeamAccess: allowTeamAccess, useDomainPool: useDomainPool, expiresAt: expiresAt, expiresIn: expiresIn, emailAddress: emailAddress, inboxType: inboxType, _description: _description, name: name, tags: tags, favourite: favourite, virtualInbox: virtualInbox, useShortAddress: useShortAddress, domainName: domainName, domainId: domainId, _prefix: _prefix, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create new random inbox
     - POST /newEmailAddress
     - Returns an Inbox with an `id` and an `emailAddress`
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter allowTeamAccess: (query)  (optional)
     - parameter useDomainPool: (query)  (optional)
     - parameter expiresAt: (query)  (optional)
     - parameter expiresIn: (query)  (optional)
     - parameter emailAddress: (query)  (optional)
     - parameter inboxType: (query)  (optional)
     - parameter _description: (query)  (optional)
     - parameter name: (query)  (optional)
     - parameter tags: (query)  (optional)
     - parameter favourite: (query)  (optional)
     - parameter virtualInbox: (query)  (optional)
     - parameter useShortAddress: (query)  (optional)
     - parameter domainName: (query)  (optional)
     - parameter domainId: (query)  (optional)
     - parameter _prefix: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<InboxDto> 
     */
    open class func createNewEmailAddressWithRequestBuilder(allowTeamAccess: Bool? = nil, useDomainPool: Bool? = nil, expiresAt: Date? = nil, expiresIn: Int64? = nil, emailAddress: String? = nil, inboxType: InboxType_createNewEmailAddress? = nil, _description: String? = nil, name: String? = nil, tags: [String]? = nil, favourite: Bool? = nil, virtualInbox: Bool? = nil, useShortAddress: Bool? = nil, domainName: String? = nil, domainId: UUID? = nil, _prefix: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<InboxDto> {
        let localVariablePath = "/newEmailAddress"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "allowTeamAccess": (wrappedValue: allowTeamAccess?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "useDomainPool": (wrappedValue: useDomainPool?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "expiresAt": (wrappedValue: expiresAt?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "expiresIn": (wrappedValue: expiresIn?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "emailAddress": (wrappedValue: emailAddress?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxType": (wrappedValue: inboxType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "description": (wrappedValue: _description?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tags": (wrappedValue: tags?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "favourite": (wrappedValue: favourite?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "virtualInbox": (wrappedValue: virtualInbox?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "useShortAddress": (wrappedValue: useShortAddress?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "domainName": (wrappedValue: domainName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "domainId": (wrappedValue: domainId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "prefix": (wrappedValue: _prefix?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<InboxDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter inboxType
     */
    public enum InboxType_createRandomInbox: String, Sendable, CaseIterable {
        case httpInbox = "HTTP_INBOX"
        case smtpInbox = "SMTP_INBOX"
    }

    /**
     Create new random inbox
     
     - parameter allowTeamAccess: (query)  (optional)
     - parameter useDomainPool: (query)  (optional)
     - parameter expiresAt: (query)  (optional)
     - parameter expiresIn: (query)  (optional)
     - parameter emailAddress: (query)  (optional)
     - parameter inboxType: (query)  (optional)
     - parameter _description: (query)  (optional)
     - parameter name: (query)  (optional)
     - parameter tags: (query)  (optional)
     - parameter favourite: (query)  (optional)
     - parameter virtualInbox: (query)  (optional)
     - parameter useShortAddress: (query)  (optional)
     - parameter domainName: (query)  (optional)
     - parameter domainId: (query)  (optional)
     - parameter _prefix: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<InboxDto>
     */
    open class func createRandomInbox(allowTeamAccess: Bool? = nil, useDomainPool: Bool? = nil, expiresAt: Date? = nil, expiresIn: Int64? = nil, emailAddress: String? = nil, inboxType: InboxType_createRandomInbox? = nil, _description: String? = nil, name: String? = nil, tags: [String]? = nil, favourite: Bool? = nil, virtualInbox: Bool? = nil, useShortAddress: Bool? = nil, domainName: String? = nil, domainId: UUID? = nil, _prefix: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<InboxDto> {
        let deferred = Promise<InboxDto>.pending()
        createRandomInboxWithRequestBuilder(allowTeamAccess: allowTeamAccess, useDomainPool: useDomainPool, expiresAt: expiresAt, expiresIn: expiresIn, emailAddress: emailAddress, inboxType: inboxType, _description: _description, name: name, tags: tags, favourite: favourite, virtualInbox: virtualInbox, useShortAddress: useShortAddress, domainName: domainName, domainId: domainId, _prefix: _prefix, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create new random inbox
     - POST /createInbox
     - Returns an Inbox with an `id` and an `emailAddress`
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter allowTeamAccess: (query)  (optional)
     - parameter useDomainPool: (query)  (optional)
     - parameter expiresAt: (query)  (optional)
     - parameter expiresIn: (query)  (optional)
     - parameter emailAddress: (query)  (optional)
     - parameter inboxType: (query)  (optional)
     - parameter _description: (query)  (optional)
     - parameter name: (query)  (optional)
     - parameter tags: (query)  (optional)
     - parameter favourite: (query)  (optional)
     - parameter virtualInbox: (query)  (optional)
     - parameter useShortAddress: (query)  (optional)
     - parameter domainName: (query)  (optional)
     - parameter domainId: (query)  (optional)
     - parameter _prefix: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<InboxDto> 
     */
    open class func createRandomInboxWithRequestBuilder(allowTeamAccess: Bool? = nil, useDomainPool: Bool? = nil, expiresAt: Date? = nil, expiresIn: Int64? = nil, emailAddress: String? = nil, inboxType: InboxType_createRandomInbox? = nil, _description: String? = nil, name: String? = nil, tags: [String]? = nil, favourite: Bool? = nil, virtualInbox: Bool? = nil, useShortAddress: Bool? = nil, domainName: String? = nil, domainId: UUID? = nil, _prefix: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<InboxDto> {
        let localVariablePath = "/createInbox"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "allowTeamAccess": (wrappedValue: allowTeamAccess?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "useDomainPool": (wrappedValue: useDomainPool?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "expiresAt": (wrappedValue: expiresAt?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "expiresIn": (wrappedValue: expiresIn?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "emailAddress": (wrappedValue: emailAddress?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxType": (wrappedValue: inboxType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "description": (wrappedValue: _description?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "name": (wrappedValue: name?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "tags": (wrappedValue: tags?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "favourite": (wrappedValue: favourite?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "virtualInbox": (wrappedValue: virtualInbox?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "useShortAddress": (wrappedValue: useShortAddress?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "domainName": (wrappedValue: domainName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "domainId": (wrappedValue: domainId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "prefix": (wrappedValue: _prefix?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<InboxDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete inbox email address by inbox id
     
     - parameter inboxId: (query) ID of inbox to delete 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteEmailAddress(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteEmailAddressWithRequestBuilder(inboxId: inboxId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete inbox email address by inbox id
     - DELETE /deleteEmailAddress
     - Deletes inbox email address
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (query) ID of inbox to delete 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteEmailAddressWithRequestBuilder(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/deleteEmailAddress"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete all emails in an inbox
     
     - parameter inboxId: (query) ID of inbox to empty 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func emptyInbox(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        emptyInboxWithRequestBuilder(inboxId: inboxId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all emails in an inbox
     - DELETE /emptyInbox
     - Deletes all emails
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (query) ID of inbox to empty 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func emptyInboxWithRequestBuilder(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/emptyInbox"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send an email using query parameters
     
     - parameter to: (query) Email address to send to 
     - parameter senderId: (query) ID of inbox to send from. If null an inbox will be created for sending (optional)
     - parameter body: (query) Body of the email message. Supports HTML (optional)
     - parameter subject: (query) Subject line of the email (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func sendEmailQuery(to: String, senderId: UUID? = nil, body: String? = nil, subject: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        sendEmailQueryWithRequestBuilder(to: to, senderId: senderId, body: body, subject: subject, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send an email using query parameters
     - POST /sendEmailQuery
     - If no senderId or inboxId provided a random email address will be used to send from. Ensure your parameters are URL encoded.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter to: (query) Email address to send to 
     - parameter senderId: (query) ID of inbox to send from. If null an inbox will be created for sending (optional)
     - parameter body: (query) Body of the email message. Supports HTML (optional)
     - parameter subject: (query) Subject line of the email (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func sendEmailQueryWithRequestBuilder(to: String, senderId: UUID? = nil, body: String? = nil, subject: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/sendEmailQuery"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "senderId": (wrappedValue: senderId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "to": (wrappedValue: to.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "body": (wrappedValue: body?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "subject": (wrappedValue: subject?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send an email
     
     - parameter simpleSendEmailOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func sendEmailSimple(simpleSendEmailOptions: SimpleSendEmailOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        sendEmailSimpleWithRequestBuilder(simpleSendEmailOptions: simpleSendEmailOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send an email
     - POST /sendEmail
     - If no senderId or inboxId provided a random email address will be used to send from.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter simpleSendEmailOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func sendEmailSimpleWithRequestBuilder(simpleSendEmailOptions: SimpleSendEmailOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/sendEmail"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: simpleSendEmailOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }
}
