//
// ConnectorControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
@preconcurrency import PromiseKit

@objcMembers open class ConnectorControllerAPI : NSObject {

    /**
     Create an inbox connector
     
     - parameter createConnectorOptions: (body)  
     - parameter inboxId: (query) Optional inbox ID to associate with the connector (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorDto>
     */
    open class func createConnector(createConnectorOptions: CreateConnectorOptions, inboxId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorDto> {
        let deferred = Promise<ConnectorDto>.pending()
        createConnectorWithRequestBuilder(createConnectorOptions: createConnectorOptions, inboxId: inboxId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector
     - POST /connectors
     - Sync emails between external mailboxes and MailSlurp inboxes
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter createConnectorOptions: (body)  
     - parameter inboxId: (query) Optional inbox ID to associate with the connector (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorDto> 
     */
    open class func createConnectorWithRequestBuilder(createConnectorOptions: CreateConnectorOptions, inboxId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorDto> {
        let localVariablePath = "/connectors"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorOptions, codableHelper: apiConfiguration.codableHelper)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Create an inbox connector IMAP connection
     
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorImapConnectionDto>
     */
    open class func createConnectorImapConnection(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorImapConnectionDto> {
        let deferred = Promise<ConnectorImapConnectionDto>.pending()
        createConnectorImapConnectionWithRequestBuilder(_id: _id, createConnectorImapConnectionOptions: createConnectorImapConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector IMAP connection
     - POST /connectors/{id}/imap
     - Allows the reading of emails in an external mailbox and syncing to a MailSlurp inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorImapConnectionDto> 
     */
    open class func createConnectorImapConnectionWithRequestBuilder(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorImapConnectionDto> {
        var localVariablePath = "/connectors/{id}/imap"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorImapConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorImapConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Create an inbox connector SMTP connection
     
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSmtpConnectionDto>
     */
    open class func createConnectorSmtpConnection(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSmtpConnectionDto> {
        let deferred = Promise<ConnectorSmtpConnectionDto>.pending()
        createConnectorSmtpConnectionWithRequestBuilder(_id: _id, createConnectorSmtpConnectionOptions: createConnectorSmtpConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector SMTP connection
     - POST /connectors/{id}/smtp
     - Allows sending via connector and email is routed to connected inbox and sent via SMTP
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSmtpConnectionDto> 
     */
    open class func createConnectorSmtpConnectionWithRequestBuilder(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSmtpConnectionDto> {
        var localVariablePath = "/connectors/{id}/smtp"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorSmtpConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSmtpConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Create an inbox connector sync settings
     
     - parameter _id: (path)  
     - parameter createConnectorSyncSettingsOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSyncSettingsDto>
     */
    open class func createConnectorSyncSettings(_id: UUID, createConnectorSyncSettingsOptions: CreateConnectorSyncSettingsOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSyncSettingsDto> {
        let deferred = Promise<ConnectorSyncSettingsDto>.pending()
        createConnectorSyncSettingsWithRequestBuilder(_id: _id, createConnectorSyncSettingsOptions: createConnectorSyncSettingsOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector sync settings
     - POST /connectors/{id}/sync-settings
     - Configure automatic pull or emails from external inboxes using an interval or schedule
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorSyncSettingsOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSyncSettingsDto> 
     */
    open class func createConnectorSyncSettingsWithRequestBuilder(_id: UUID, createConnectorSyncSettingsOptions: CreateConnectorSyncSettingsOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSyncSettingsDto> {
        var localVariablePath = "/connectors/{id}/sync-settings"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorSyncSettingsOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSyncSettingsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Create an inbox connector with options
     
     - parameter createConnectorWithOptions: (body)  
     - parameter inboxId: (query) Optional inbox ID to associate with the connector (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorDto>
     */
    open class func createConnectorWithOptions(createConnectorWithOptions: CreateConnectorWithOptions, inboxId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorDto> {
        let deferred = Promise<ConnectorDto>.pending()
        createConnectorWithOptionsWithRequestBuilder(createConnectorWithOptions: createConnectorWithOptions, inboxId: inboxId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector with options
     - POST /connectors/withOptions
     - Sync emails between external mailboxes and MailSlurp inboxes
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter createConnectorWithOptions: (body)  
     - parameter inboxId: (query) Optional inbox ID to associate with the connector (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorDto> 
     */
    open class func createConnectorWithOptionsWithRequestBuilder(createConnectorWithOptions: CreateConnectorWithOptions, inboxId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorDto> {
        let localVariablePath = "/connectors/withOptions"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorWithOptions, codableHelper: apiConfiguration.codableHelper)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete all inbox connectors
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteAllConnector(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteAllConnectorWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all inbox connectors
     - DELETE /connectors
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteAllConnectorWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/connectors"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete an inbox connector
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteConnector(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteConnectorWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete an inbox connector
     - DELETE /connectors/{id}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteConnectorWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/connectors/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete an inbox connector IMAP connection
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteConnectorImapConnection(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteConnectorImapConnectionWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete an inbox connector IMAP connection
     - DELETE /connectors/{id}/imap
     - Delete IMAP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteConnectorImapConnectionWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/connectors/{id}/imap"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete an inbox connector SMTP connection
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteConnectorSmtpConnection(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteConnectorSmtpConnectionWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete an inbox connector SMTP connection
     - DELETE /connectors/{id}/smtp
     - Delete SMTP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteConnectorSmtpConnectionWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/connectors/{id}/smtp"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Create an inbox connector sync settings
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteConnectorSyncSettings(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteConnectorSyncSettingsWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create an inbox connector sync settings
     - DELETE /connectors/{id}/sync-settings
     - Configure automatic pull or emails from external inboxes using an interval or schedule
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteConnectorSyncSettingsWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/connectors/{id}/sync-settings"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllConnectorEvents: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getAllConnectorEvents: String, Sendable, CaseIterable {
        case send = "SEND"
        case sync = "SYNC"
    }

    /**
     Get all inbox connector events
     
     - parameter _id: (query) Optional connector ID (optional)
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Filter by event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageConnectorEvents>
     */
    open class func getAllConnectorEvents(_id: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getAllConnectorEvents? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getAllConnectorEvents? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageConnectorEvents> {
        let deferred = Promise<PageConnectorEvents>.pending()
        getAllConnectorEventsWithRequestBuilder(_id: _id, page: page, size: size, sort: sort, since: since, before: before, eventType: eventType, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all inbox connector events
     - GET /connectors/events
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (query) Optional connector ID (optional)
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Filter by event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageConnectorEvents> 
     */
    open class func getAllConnectorEventsWithRequestBuilder(_id: UUID? = nil, page: Int? = nil, size: Int? = nil, sort: Sort_getAllConnectorEvents? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getAllConnectorEvents? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageConnectorEvents> {
        let localVariablePath = "/connectors/events"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "id": (wrappedValue: _id?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageConnectorEvents>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get an inbox connector
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorDto>
     */
    open class func getConnector(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorDto> {
        let deferred = Promise<ConnectorDto>.pending()
        getConnectorWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector
     - GET /connectors/{id}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorDto> 
     */
    open class func getConnectorWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorDto> {
        var localVariablePath = "/connectors/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get connector by email address
     
     - parameter emailAddress: (query) Email address to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorDto>
     */
    open class func getConnectorByEmailAddress(emailAddress: String, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorDto> {
        let deferred = Promise<OptionalConnectorDto>.pending()
        getConnectorByEmailAddressWithRequestBuilder(emailAddress: emailAddress, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get connector by email address
     - GET /connectors/by-email-address
     - Find an inbox connector by email address
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter emailAddress: (query) Email address to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorDto> 
     */
    open class func getConnectorByEmailAddressWithRequestBuilder(emailAddress: String, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorDto> {
        let localVariablePath = "/connectors/by-email-address"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "emailAddress": (wrappedValue: emailAddress.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get connector by inbox ID
     
     - parameter inboxId: (query) Inbox ID to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorDto>
     */
    open class func getConnectorByInboxId(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorDto> {
        let deferred = Promise<OptionalConnectorDto>.pending()
        getConnectorByInboxIdWithRequestBuilder(inboxId: inboxId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get connector by inbox ID
     - GET /connectors/by-inbox-id
     - Find an inbox connector by inbox ID
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (query) Inbox ID to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorDto> 
     */
    open class func getConnectorByInboxIdWithRequestBuilder(inboxId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorDto> {
        let localVariablePath = "/connectors/by-inbox-id"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get connector by name
     
     - parameter name: (query) Name to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorDto>
     */
    open class func getConnectorByName(name: String, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorDto> {
        let deferred = Promise<OptionalConnectorDto>.pending()
        getConnectorByNameWithRequestBuilder(name: name, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get connector by name
     - GET /connectors/by-name
     - Find an inbox connector by name
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter name: (query) Name to search for connector by 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorDto> 
     */
    open class func getConnectorByNameWithRequestBuilder(name: String, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorDto> {
        let localVariablePath = "/connectors/by-name"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "name": (wrappedValue: name.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get an inbox connector event
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorEventDto>
     */
    open class func getConnectorEvent(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorEventDto> {
        let deferred = Promise<ConnectorEventDto>.pending()
        getConnectorEventWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector event
     - GET /connectors/events/{id}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorEventDto> 
     */
    open class func getConnectorEventWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorEventDto> {
        var localVariablePath = "/connectors/events/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorEventDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getConnectorEvents: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getConnectorEvents: String, Sendable, CaseIterable {
        case send = "SEND"
        case sync = "SYNC"
    }

    /**
     Get an inbox connector events
     
     - parameter _id: (path)  
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Filter by event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageConnectorEvents>
     */
    open class func getConnectorEvents(_id: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getConnectorEvents? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getConnectorEvents? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageConnectorEvents> {
        let deferred = Promise<PageConnectorEvents>.pending()
        getConnectorEventsWithRequestBuilder(_id: _id, page: page, size: size, sort: sort, since: since, before: before, eventType: eventType, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector events
     - GET /connectors/{id}/events
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Filter by event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageConnectorEvents> 
     */
    open class func getConnectorEventsWithRequestBuilder(_id: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getConnectorEvents? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getConnectorEvents? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageConnectorEvents> {
        var localVariablePath = "/connectors/{id}/events"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageConnectorEvents>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get an inbox connector IMAP connection
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorImapConnectionDto>
     */
    open class func getConnectorImapConnection(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorImapConnectionDto> {
        let deferred = Promise<OptionalConnectorImapConnectionDto>.pending()
        getConnectorImapConnectionWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector IMAP connection
     - GET /connectors/{id}/imap
     - Get IMAP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorImapConnectionDto> 
     */
    open class func getConnectorImapConnectionWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorImapConnectionDto> {
        var localVariablePath = "/connectors/{id}/imap"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorImapConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get SMTP and IMAP connection settings for common mail providers
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorProviderSettingsDto>
     */
    open class func getConnectorProviderSettings(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorProviderSettingsDto> {
        let deferred = Promise<ConnectorProviderSettingsDto>.pending()
        getConnectorProviderSettingsWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get SMTP and IMAP connection settings for common mail providers
     - GET /connectors/provider-settings
     - Get common mail provider SMTP and IMAP connection settings
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorProviderSettingsDto> 
     */
    open class func getConnectorProviderSettingsWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorProviderSettingsDto> {
        let localVariablePath = "/connectors/provider-settings"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorProviderSettingsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get an inbox connector SMTP connection
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorSmtpConnectionDto>
     */
    open class func getConnectorSmtpConnection(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorSmtpConnectionDto> {
        let deferred = Promise<OptionalConnectorSmtpConnectionDto>.pending()
        getConnectorSmtpConnectionWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector SMTP connection
     - GET /connectors/{id}/smtp
     - Get SMTP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorSmtpConnectionDto> 
     */
    open class func getConnectorSmtpConnectionWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorSmtpConnectionDto> {
        var localVariablePath = "/connectors/{id}/smtp"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorSmtpConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get an inbox connector sync settings
     
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<OptionalConnectorSyncSettingsDto>
     */
    open class func getConnectorSyncSettings(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<OptionalConnectorSyncSettingsDto> {
        let deferred = Promise<OptionalConnectorSyncSettingsDto>.pending()
        getConnectorSyncSettingsWithRequestBuilder(_id: _id, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get an inbox connector sync settings
     - GET /connectors/{id}/sync-settings
     - Get sync settings for connection with external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<OptionalConnectorSyncSettingsDto> 
     */
    open class func getConnectorSyncSettingsWithRequestBuilder(_id: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<OptionalConnectorSyncSettingsDto> {
        var localVariablePath = "/connectors/{id}/sync-settings"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<OptionalConnectorSyncSettingsDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getConnectors: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get inbox connectors
     
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageConnector>
     */
    open class func getConnectors(page: Int? = nil, size: Int? = nil, sort: Sort_getConnectors? = nil, since: Date? = nil, before: Date? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageConnector> {
        let deferred = Promise<PageConnector>.pending()
        getConnectorsWithRequestBuilder(page: page, size: size, sort: sort, since: since, before: before, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get inbox connectors
     - GET /connectors
     - List inbox connectors that sync external emails to MailSlurp inboxes
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter page: (query) Optional page index in connector list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in connector list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageConnector> 
     */
    open class func getConnectorsWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getConnectors? = nil, since: Date? = nil, before: Date? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageConnector> {
        let localVariablePath = "/connectors"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageConnector>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send from an inbox connector
     
     - parameter _id: (path)  
     - parameter sendEmailOptions: (body)  
     - parameter useFallback: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<SentEmailDto>
     */
    open class func sendEmailFromConnector(_id: UUID, sendEmailOptions: SendEmailOptions, useFallback: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<SentEmailDto> {
        let deferred = Promise<SentEmailDto>.pending()
        sendEmailFromConnectorWithRequestBuilder(_id: _id, sendEmailOptions: sendEmailOptions, useFallback: useFallback, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send from an inbox connector
     - POST /connectors/{id}/send
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter sendEmailOptions: (body)  
     - parameter useFallback: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<SentEmailDto> 
     */
    open class func sendEmailFromConnectorWithRequestBuilder(_id: UUID, sendEmailOptions: SendEmailOptions, useFallback: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<SentEmailDto> {
        var localVariablePath = "/connectors/{id}/send"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: sendEmailOptions, codableHelper: apiConfiguration.codableHelper)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "useFallback": (wrappedValue: useFallback?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<SentEmailDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Sync an inbox connector
     
     - parameter _id: (path)  
     - parameter since: (query) Date to request emails since (optional)
     - parameter folder: (query) Which folder to sync emails with (optional)
     - parameter logging: (query) Enable or disable logging for the sync operation (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSyncRequestResult>
     */
    open class func syncConnector(_id: UUID, since: Date? = nil, folder: String? = nil, logging: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSyncRequestResult> {
        let deferred = Promise<ConnectorSyncRequestResult>.pending()
        syncConnectorWithRequestBuilder(_id: _id, since: since, folder: folder, logging: logging, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Sync an inbox connector
     - POST /connectors/{id}/sync
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter since: (query) Date to request emails since (optional)
     - parameter folder: (query) Which folder to sync emails with (optional)
     - parameter logging: (query) Enable or disable logging for the sync operation (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSyncRequestResult> 
     */
    open class func syncConnectorWithRequestBuilder(_id: UUID, since: Date? = nil, folder: String? = nil, logging: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSyncRequestResult> {
        var localVariablePath = "/connectors/{id}/sync"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "folder": (wrappedValue: folder?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "logging": (wrappedValue: logging?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSyncRequestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Test an inbox connector IMAP connection
     
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorImapConnectionTestResult>
     */
    open class func testConnectorImapConnection(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorImapConnectionTestResult> {
        let deferred = Promise<ConnectorImapConnectionTestResult>.pending()
        testConnectorImapConnectionWithRequestBuilder(_id: _id, createConnectorImapConnectionOptions: createConnectorImapConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Test an inbox connector IMAP connection
     - POST /connectors/{id}/imap/test
     - Test the IMAP connection for a connector
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorImapConnectionTestResult> 
     */
    open class func testConnectorImapConnectionWithRequestBuilder(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorImapConnectionTestResult> {
        var localVariablePath = "/connectors/{id}/imap/test"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorImapConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorImapConnectionTestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Test an inbox connector IMAP connection options
     
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorImapConnectionTestResult>
     */
    open class func testConnectorImapConnectionOptions(createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorImapConnectionTestResult> {
        let deferred = Promise<ConnectorImapConnectionTestResult>.pending()
        testConnectorImapConnectionOptionsWithRequestBuilder(createConnectorImapConnectionOptions: createConnectorImapConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Test an inbox connector IMAP connection options
     - POST /connectors/connections/imap/test
     - Test the IMAP connection options for a connector
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorImapConnectionTestResult> 
     */
    open class func testConnectorImapConnectionOptionsWithRequestBuilder(createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorImapConnectionTestResult> {
        let localVariablePath = "/connectors/connections/imap/test"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorImapConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorImapConnectionTestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Test an inbox connector SMTP connection
     
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSmtpConnectionTestResult>
     */
    open class func testConnectorSmtpConnection(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSmtpConnectionTestResult> {
        let deferred = Promise<ConnectorSmtpConnectionTestResult>.pending()
        testConnectorSmtpConnectionWithRequestBuilder(_id: _id, createConnectorSmtpConnectionOptions: createConnectorSmtpConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Test an inbox connector SMTP connection
     - POST /connectors/{id}/smtp/test
     - Test the SMTP connection for a connector
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSmtpConnectionTestResult> 
     */
    open class func testConnectorSmtpConnectionWithRequestBuilder(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSmtpConnectionTestResult> {
        var localVariablePath = "/connectors/{id}/smtp/test"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorSmtpConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSmtpConnectionTestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Test an inbox connector SMTP connection options
     
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSmtpConnectionTestResult>
     */
    open class func testConnectorSmtpConnectionOptions(createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSmtpConnectionTestResult> {
        let deferred = Promise<ConnectorSmtpConnectionTestResult>.pending()
        testConnectorSmtpConnectionOptionsWithRequestBuilder(createConnectorSmtpConnectionOptions: createConnectorSmtpConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Test an inbox connector SMTP connection options
     - POST /connectors/connections/smtp/test
     - Test the SMTP connection options for a connector
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSmtpConnectionTestResult> 
     */
    open class func testConnectorSmtpConnectionOptionsWithRequestBuilder(createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSmtpConnectionTestResult> {
        let localVariablePath = "/connectors/connections/smtp/test"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorSmtpConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSmtpConnectionTestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Update an inbox connector
     
     - parameter _id: (path)  
     - parameter createConnectorOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorDto>
     */
    open class func updateConnector(_id: UUID, createConnectorOptions: CreateConnectorOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorDto> {
        let deferred = Promise<ConnectorDto>.pending()
        updateConnectorWithRequestBuilder(_id: _id, createConnectorOptions: createConnectorOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update an inbox connector
     - PUT /connectors/{id}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorDto> 
     */
    open class func updateConnectorWithRequestBuilder(_id: UUID, createConnectorOptions: CreateConnectorOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorDto> {
        var localVariablePath = "/connectors/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Update an inbox connector IMAP connection
     
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorImapConnectionDto>
     */
    open class func updateConnectorImapConnection(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorImapConnectionDto> {
        let deferred = Promise<ConnectorImapConnectionDto>.pending()
        updateConnectorImapConnectionWithRequestBuilder(_id: _id, createConnectorImapConnectionOptions: createConnectorImapConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update an inbox connector IMAP connection
     - PATCH /connectors/{id}/imap
     - Update IMAP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorImapConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorImapConnectionDto> 
     */
    open class func updateConnectorImapConnectionWithRequestBuilder(_id: UUID, createConnectorImapConnectionOptions: CreateConnectorImapConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorImapConnectionDto> {
        var localVariablePath = "/connectors/{id}/imap"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorImapConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorImapConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PATCH", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Update an inbox connector SMTP connection
     
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<ConnectorSmtpConnectionDto>
     */
    open class func updateConnectorSmtpConnection(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<ConnectorSmtpConnectionDto> {
        let deferred = Promise<ConnectorSmtpConnectionDto>.pending()
        updateConnectorSmtpConnectionWithRequestBuilder(_id: _id, createConnectorSmtpConnectionOptions: createConnectorSmtpConnectionOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update an inbox connector SMTP connection
     - PATCH /connectors/{id}/smtp
     - Update SMTP connection for external inbox
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter _id: (path)  
     - parameter createConnectorSmtpConnectionOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<ConnectorSmtpConnectionDto> 
     */
    open class func updateConnectorSmtpConnectionWithRequestBuilder(_id: UUID, createConnectorSmtpConnectionOptions: CreateConnectorSmtpConnectionOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<ConnectorSmtpConnectionDto> {
        var localVariablePath = "/connectors/{id}/smtp"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createConnectorSmtpConnectionOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<ConnectorSmtpConnectionDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PATCH", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }
}
