//
// WebhookControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
@preconcurrency import PromiseKit

@objcMembers open class WebhookControllerAPI : NSObject {

    /**
     Attach a WebHook URL to an inbox
     
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func createAccountWebhook(createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        createAccountWebhookWithRequestBuilder(createWebhookOptions: createWebhookOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Attach a WebHook URL to an inbox
     - POST /webhooks
     - Get notified of account level events such as bounce and bounce recipient.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func createAccountWebhookWithRequestBuilder(createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        let localVariablePath = "/webhooks"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createWebhookOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Attach a WebHook URL to an inbox
     
     - parameter inboxId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func createWebhook(inboxId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        createWebhookWithRequestBuilder(inboxId: inboxId, createWebhookOptions: createWebhookOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Attach a WebHook URL to an inbox
     - POST /inboxes/{inboxId}/webhooks
     - Get notified whenever an inbox receives an email via a WebHook URL. An emailID will be posted to this URL every time an email is received for this inbox. The URL must be publicly reachable by the MailSlurp server. You can provide basicAuth values if you wish to secure this endpoint.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func createWebhookWithRequestBuilder(inboxId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/inboxes/{inboxId}/webhooks"
        let inboxIdPreEscape = "\(APIHelper.mapValueToPathItem(inboxId))"
        let inboxIdPostEscape = inboxIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{inboxId}", with: inboxIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createWebhookOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Attach a WebHook URL to an AI transformer
     
     - parameter transformerId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func createWebhookForAITransformer(transformerId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        createWebhookForAITransformerWithRequestBuilder(transformerId: transformerId, createWebhookOptions: createWebhookOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Attach a WebHook URL to an AI transformer
     - POST /ai-transformers/{transformerId}/webhooks
     - Get notified whenever AI transformation pipeline converts and email or SMS into structured data via a WebHook URL.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter transformerId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func createWebhookForAITransformerWithRequestBuilder(transformerId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/ai-transformers/{transformerId}/webhooks"
        let transformerIdPreEscape = "\(APIHelper.mapValueToPathItem(transformerId))"
        let transformerIdPostEscape = transformerIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{transformerId}", with: transformerIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createWebhookOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Attach a WebHook URL to a phone number
     
     - parameter phoneNumberId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func createWebhookForPhoneNumber(phoneNumberId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        createWebhookForPhoneNumberWithRequestBuilder(phoneNumberId: phoneNumberId, createWebhookOptions: createWebhookOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Attach a WebHook URL to a phone number
     - POST /phone/numbers/{phoneNumberId}/webhooks
     - Get notified whenever a phone number receives an SMS via a WebHook URL.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneNumberId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func createWebhookForPhoneNumberWithRequestBuilder(phoneNumberId: UUID, createWebhookOptions: CreateWebhookOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/phone/numbers/{phoneNumberId}/webhooks"
        let phoneNumberIdPreEscape = "\(APIHelper.mapValueToPathItem(phoneNumberId))"
        let phoneNumberIdPostEscape = phoneNumberIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{phoneNumberId}", with: phoneNumberIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createWebhookOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete all webhooks
     
     - parameter before: (query) before (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteAllWebhooks(before: Date? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteAllWebhooksWithRequestBuilder(before: before, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all webhooks
     - DELETE /webhooks
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter before: (query) before (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteAllWebhooksWithRequestBuilder(before: Date? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        let localVariablePath = "/webhooks"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete and disable a Webhook for an Inbox
     
     - parameter inboxId: (path)  
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteWebhook(inboxId: UUID, webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteWebhookWithRequestBuilder(inboxId: inboxId, webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete and disable a Webhook for an Inbox
     - DELETE /inboxes/{inboxId}/webhooks/{webhookId}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (path)  
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteWebhookWithRequestBuilder(inboxId: UUID, webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/inboxes/{inboxId}/webhooks/{webhookId}"
        let inboxIdPreEscape = "\(APIHelper.mapValueToPathItem(inboxId))"
        let inboxIdPostEscape = inboxIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{inboxId}", with: inboxIdPostEscape, options: .literal, range: nil)
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Delete a webhook
     
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<Void>
     */
    open class func deleteWebhookById(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteWebhookByIdWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete a webhook
     - DELETE /webhooks/{webhookId}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<Void> 
     */
    open class func deleteWebhookByIdWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<Void> {
        var localVariablePath = "/webhooks/{webhookId}"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<Void>.Type = apiConfiguration.requestBuilderFactory.getNonDecodableBuilder()

        return localVariableRequestBuilder.init(method: "DELETE", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllAccountWebhooks: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getAllAccountWebhooks: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     * enum for parameter health
     */
    public enum Health_getAllAccountWebhooks: String, Sendable, CaseIterable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
    }

    /**
     List account webhooks Paginated
     
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookProjection>
     */
    open class func getAllAccountWebhooks(page: Int? = nil, size: Int? = nil, sort: Sort_getAllAccountWebhooks? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getAllAccountWebhooks? = nil, health: Health_getAllAccountWebhooks? = nil, searchFilter: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookProjection> {
        let deferred = Promise<PageWebhookProjection>.pending()
        getAllAccountWebhooksWithRequestBuilder(page: page, size: size, sort: sort, since: since, before: before, eventType: eventType, health: health, searchFilter: searchFilter, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     List account webhooks Paginated
     - GET /webhooks/account/paginated
     - List account webhooks in paginated form. Allows for page index, page size, and sort direction.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookProjection> 
     */
    open class func getAllAccountWebhooksWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getAllAccountWebhooks? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getAllAccountWebhooks? = nil, health: Health_getAllAccountWebhooks? = nil, searchFilter: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookProjection> {
        let localVariablePath = "/webhooks/account/paginated"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "health": (wrappedValue: health?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllWebhookEndpoints: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter health
     */
    public enum Health_getAllWebhookEndpoints: String, Sendable, CaseIterable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getAllWebhookEndpoints: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     List Webhooks endpoints Paginated
     
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter inboxId: (query) Filter by inboxId (optional)
     - parameter phoneId: (query) Filter by phoneId (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookEndpointProjection>
     */
    open class func getAllWebhookEndpoints(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhookEndpoints? = nil, searchFilter: String? = nil, since: Date? = nil, inboxId: UUID? = nil, phoneId: UUID? = nil, before: Date? = nil, health: Health_getAllWebhookEndpoints? = nil, eventType: EventType_getAllWebhookEndpoints? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookEndpointProjection> {
        let deferred = Promise<PageWebhookEndpointProjection>.pending()
        getAllWebhookEndpointsWithRequestBuilder(page: page, size: size, sort: sort, searchFilter: searchFilter, since: since, inboxId: inboxId, phoneId: phoneId, before: before, health: health, eventType: eventType, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     List Webhooks endpoints Paginated
     - GET /webhooks/endpoints
     - List webhooks URL in paginated form. Allows for page index, page size, and sort direction.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter inboxId: (query) Filter by inboxId (optional)
     - parameter phoneId: (query) Filter by phoneId (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookEndpointProjection> 
     */
    open class func getAllWebhookEndpointsWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhookEndpoints? = nil, searchFilter: String? = nil, since: Date? = nil, inboxId: UUID? = nil, phoneId: UUID? = nil, before: Date? = nil, health: Health_getAllWebhookEndpoints? = nil, eventType: EventType_getAllWebhookEndpoints? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookEndpointProjection> {
        let localVariablePath = "/webhooks/endpoints"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "phoneId": (wrappedValue: phoneId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "health": (wrappedValue: health?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookEndpointProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllWebhookResults: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter resultType
     */
    public enum ResultType_getAllWebhookResults: String, Sendable, CaseIterable {
        case badResponse = "BAD_RESPONSE"
        case exception = "EXCEPTION"
        case success = "SUCCESS"
        case redriven = "REDRIVEN"
    }

    /**
     * enum for parameter eventName
     */
    public enum EventName_getAllWebhookResults: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     Get results for all webhooks
     
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter unseenOnly: (query) Filter for unseen exceptions only (optional)
     - parameter resultType: (query) Filter by result type (optional)
     - parameter eventName: (query) Filter by event name (optional)
     - parameter minStatusCode: (query) Minimum response status (optional)
     - parameter maxStatusCode: (query) Maximum response status (optional)
     - parameter inboxId: (query) Inbox ID (optional)
     - parameter smsId: (query) Sms ID (optional)
     - parameter attachmentId: (query) Attachment ID (optional)
     - parameter emailId: (query) Email ID (optional)
     - parameter phoneId: (query) Phone ID (optional)
     - parameter aiTransformerId: (query) AI Transformer ID (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookResult>
     */
    open class func getAllWebhookResults(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhookResults? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, unseenOnly: Bool? = nil, resultType: ResultType_getAllWebhookResults? = nil, eventName: EventName_getAllWebhookResults? = nil, minStatusCode: Int? = nil, maxStatusCode: Int? = nil, inboxId: UUID? = nil, smsId: UUID? = nil, attachmentId: UUID? = nil, emailId: UUID? = nil, phoneId: UUID? = nil, aiTransformerId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookResult> {
        let deferred = Promise<PageWebhookResult>.pending()
        getAllWebhookResultsWithRequestBuilder(page: page, size: size, sort: sort, searchFilter: searchFilter, since: since, before: before, unseenOnly: unseenOnly, resultType: resultType, eventName: eventName, minStatusCode: minStatusCode, maxStatusCode: maxStatusCode, inboxId: inboxId, smsId: smsId, attachmentId: attachmentId, emailId: emailId, phoneId: phoneId, aiTransformerId: aiTransformerId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get results for all webhooks
     - GET /webhooks/results
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter unseenOnly: (query) Filter for unseen exceptions only (optional)
     - parameter resultType: (query) Filter by result type (optional)
     - parameter eventName: (query) Filter by event name (optional)
     - parameter minStatusCode: (query) Minimum response status (optional)
     - parameter maxStatusCode: (query) Maximum response status (optional)
     - parameter inboxId: (query) Inbox ID (optional)
     - parameter smsId: (query) Sms ID (optional)
     - parameter attachmentId: (query) Attachment ID (optional)
     - parameter emailId: (query) Email ID (optional)
     - parameter phoneId: (query) Phone ID (optional)
     - parameter aiTransformerId: (query) AI Transformer ID (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookResult> 
     */
    open class func getAllWebhookResultsWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhookResults? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, unseenOnly: Bool? = nil, resultType: ResultType_getAllWebhookResults? = nil, eventName: EventName_getAllWebhookResults? = nil, minStatusCode: Int? = nil, maxStatusCode: Int? = nil, inboxId: UUID? = nil, smsId: UUID? = nil, attachmentId: UUID? = nil, emailId: UUID? = nil, phoneId: UUID? = nil, aiTransformerId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookResult> {
        let localVariablePath = "/webhooks/results"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "unseenOnly": (wrappedValue: unseenOnly?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "resultType": (wrappedValue: resultType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventName": (wrappedValue: eventName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "minStatusCode": (wrappedValue: minStatusCode?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "maxStatusCode": (wrappedValue: maxStatusCode?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "smsId": (wrappedValue: smsId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "attachmentId": (wrappedValue: attachmentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "emailId": (wrappedValue: emailId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "phoneId": (wrappedValue: phoneId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "aiTransformerId": (wrappedValue: aiTransformerId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getAllWebhooks: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter health
     */
    public enum Health_getAllWebhooks: String, Sendable, CaseIterable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getAllWebhooks: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     List Webhooks Paginated
     
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter inboxId: (query) Filter by inboxId (optional)
     - parameter aiTransformerId: (query) Filter by aiTransformerId (optional)
     - parameter phoneId: (query) Filter by phoneId (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter url: (query) Optional url endpoint filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookProjection>
     */
    open class func getAllWebhooks(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhooks? = nil, searchFilter: String? = nil, since: Date? = nil, inboxId: UUID? = nil, aiTransformerId: UUID? = nil, phoneId: UUID? = nil, before: Date? = nil, health: Health_getAllWebhooks? = nil, eventType: EventType_getAllWebhooks? = nil, url: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookProjection> {
        let deferred = Promise<PageWebhookProjection>.pending()
        getAllWebhooksWithRequestBuilder(page: page, size: size, sort: sort, searchFilter: searchFilter, since: since, inboxId: inboxId, aiTransformerId: aiTransformerId, phoneId: phoneId, before: before, health: health, eventType: eventType, url: url, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     List Webhooks Paginated
     - GET /webhooks/paginated
     - List webhooks in paginated form. Allows for page index, page size, and sort direction.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size for paginated result list. (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .desc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter inboxId: (query) Filter by inboxId (optional)
     - parameter aiTransformerId: (query) Filter by aiTransformerId (optional)
     - parameter phoneId: (query) Filter by phoneId (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter url: (query) Optional url endpoint filter (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookProjection> 
     */
    open class func getAllWebhooksWithRequestBuilder(page: Int? = nil, size: Int? = nil, sort: Sort_getAllWebhooks? = nil, searchFilter: String? = nil, since: Date? = nil, inboxId: UUID? = nil, aiTransformerId: UUID? = nil, phoneId: UUID? = nil, before: Date? = nil, health: Health_getAllWebhooks? = nil, eventType: EventType_getAllWebhooks? = nil, url: String? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookProjection> {
        let localVariablePath = "/webhooks/paginated"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "aiTransformerId": (wrappedValue: aiTransformerId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "phoneId": (wrappedValue: phoneId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "health": (wrappedValue: health?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "url": (wrappedValue: url?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getInboxWebhooksPaginated: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter health
     */
    public enum Health_getInboxWebhooksPaginated: String, Sendable, CaseIterable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getInboxWebhooksPaginated: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     Get paginated webhooks for an Inbox
     
     - parameter inboxId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookProjection>
     */
    open class func getInboxWebhooksPaginated(inboxId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getInboxWebhooksPaginated? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, health: Health_getInboxWebhooksPaginated? = nil, eventType: EventType_getInboxWebhooksPaginated? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookProjection> {
        let deferred = Promise<PageWebhookProjection>.pending()
        getInboxWebhooksPaginatedWithRequestBuilder(inboxId: inboxId, page: page, size: size, sort: sort, searchFilter: searchFilter, since: since, before: before, health: health, eventType: eventType, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get paginated webhooks for an Inbox
     - GET /inboxes/{inboxId}/webhooks/paginated
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookProjection> 
     */
    open class func getInboxWebhooksPaginatedWithRequestBuilder(inboxId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getInboxWebhooksPaginated? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, health: Health_getInboxWebhooksPaginated? = nil, eventType: EventType_getInboxWebhooksPaginated? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookProjection> {
        var localVariablePath = "/inboxes/{inboxId}/webhooks/paginated"
        let inboxIdPreEscape = "\(APIHelper.mapValueToPathItem(inboxId))"
        let inboxIdPostEscape = inboxIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{inboxId}", with: inboxIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "health": (wrappedValue: health?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter event
     */
    public enum Event_getJsonSchemaForWebhookEvent: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**

     - parameter event: (query)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<JSONSchemaDto>
     */
    open class func getJsonSchemaForWebhookEvent(event: Event_getJsonSchemaForWebhookEvent, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<JSONSchemaDto> {
        let deferred = Promise<JSONSchemaDto>.pending()
        getJsonSchemaForWebhookEventWithRequestBuilder(event: event, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - POST /webhooks/schema
     - Get JSON Schema definition for webhook payload by event
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter event: (query)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<JSONSchemaDto> 
     */
    open class func getJsonSchemaForWebhookEventWithRequestBuilder(event: Event_getJsonSchemaForWebhookEvent, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<JSONSchemaDto> {
        let localVariablePath = "/webhooks/schema"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "event": (wrappedValue: event.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<JSONSchemaDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<JSONSchemaDto>
     */
    open class func getJsonSchemaForWebhookPayload(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<JSONSchemaDto> {
        let deferred = Promise<JSONSchemaDto>.pending()
        getJsonSchemaForWebhookPayloadWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - POST /webhooks/{webhookId}/schema
     - Get JSON Schema definition for webhook payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<JSONSchemaDto> 
     */
    open class func getJsonSchemaForWebhookPayloadWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<JSONSchemaDto> {
        var localVariablePath = "/webhooks/{webhookId}/schema"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<JSONSchemaDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getPhoneNumberWebhooksPaginated: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter eventType
     */
    public enum EventType_getPhoneNumberWebhooksPaginated: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     * enum for parameter health
     */
    public enum Health_getPhoneNumberWebhooksPaginated: String, Sendable, CaseIterable {
        case healthy = "HEALTHY"
        case unhealthy = "UNHEALTHY"
    }

    /**
     Get paginated webhooks for a phone number
     
     - parameter phoneId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookProjection>
     */
    open class func getPhoneNumberWebhooksPaginated(phoneId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getPhoneNumberWebhooksPaginated? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getPhoneNumberWebhooksPaginated? = nil, searchFilter: String? = nil, health: Health_getPhoneNumberWebhooksPaginated? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookProjection> {
        let deferred = Promise<PageWebhookProjection>.pending()
        getPhoneNumberWebhooksPaginatedWithRequestBuilder(phoneId: phoneId, page: page, size: size, sort: sort, since: since, before: before, eventType: eventType, searchFilter: searchFilter, health: health, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get paginated webhooks for a phone number
     - GET /phone/numbers/{phoneId}/webhooks/paginated
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter phoneId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter eventType: (query) Optional event type (optional)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter health: (query) Filter by webhook health (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookProjection> 
     */
    open class func getPhoneNumberWebhooksPaginatedWithRequestBuilder(phoneId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getPhoneNumberWebhooksPaginated? = nil, since: Date? = nil, before: Date? = nil, eventType: EventType_getPhoneNumberWebhooksPaginated? = nil, searchFilter: String? = nil, health: Health_getPhoneNumberWebhooksPaginated? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookProjection> {
        var localVariablePath = "/phone/numbers/{phoneId}/webhooks/paginated"
        let phoneIdPreEscape = "\(APIHelper.mapValueToPathItem(phoneId))"
        let phoneIdPostEscape = phoneIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{phoneId}", with: phoneIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventType": (wrappedValue: eventType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "health": (wrappedValue: health?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookProjection>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter eventName
     */
    public enum EventName_getTestWebhookPayload: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**

     - parameter eventName: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<AbstractWebhookPayload>
     */
    open class func getTestWebhookPayload(eventName: EventName_getTestWebhookPayload? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<AbstractWebhookPayload> {
        let deferred = Promise<AbstractWebhookPayload>.pending()
        getTestWebhookPayloadWithRequestBuilder(eventName: eventName, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /webhooks/test
     - Get test webhook payload example. Response content depends on eventName passed. Uses `EMAIL_RECEIVED` as default.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter eventName: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<AbstractWebhookPayload> 
     */
    open class func getTestWebhookPayloadWithRequestBuilder(eventName: EventName_getTestWebhookPayload? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<AbstractWebhookPayload> {
        let localVariablePath = "/webhooks/test"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "eventName": (wrappedValue: eventName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AbstractWebhookPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookBouncePayload>
     */
    open class func getTestWebhookPayloadBounce(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookBouncePayload> {
        let deferred = Promise<WebhookBouncePayload>.pending()
        getTestWebhookPayloadBounceWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /webhooks/test/email-bounce-payload
     - Get webhook test payload for bounce
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookBouncePayload> 
     */
    open class func getTestWebhookPayloadBounceWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookBouncePayload> {
        let localVariablePath = "/webhooks/test/email-bounce-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookBouncePayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookBounceRecipientPayload>
     */
    open class func getTestWebhookPayloadBounceRecipient(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookBounceRecipientPayload> {
        let deferred = Promise<WebhookBounceRecipientPayload>.pending()
        getTestWebhookPayloadBounceRecipientWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /webhooks/test/email-bounce-recipient-payload
     - Get webhook test payload for bounce recipient
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookBounceRecipientPayload> 
     */
    open class func getTestWebhookPayloadBounceRecipientWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookBounceRecipientPayload> {
        let localVariablePath = "/webhooks/test/email-bounce-recipient-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookBounceRecipientPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for delivery status event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDeliveryStatusPayload>
     */
    open class func getTestWebhookPayloadDeliveryStatus(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDeliveryStatusPayload> {
        let deferred = Promise<WebhookDeliveryStatusPayload>.pending()
        getTestWebhookPayloadDeliveryStatusWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for delivery status event
     - GET /webhooks/test/delivery-status-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDeliveryStatusPayload> 
     */
    open class func getTestWebhookPayloadDeliveryStatusWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDeliveryStatusPayload> {
        let localVariablePath = "/webhooks/test/delivery-status-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDeliveryStatusPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookEmailOpenedPayload>
     */
    open class func getTestWebhookPayloadEmailOpened(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookEmailOpenedPayload> {
        let deferred = Promise<WebhookEmailOpenedPayload>.pending()
        getTestWebhookPayloadEmailOpenedWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /webhooks/test/email-opened-payload
     - Get webhook test payload for email opened event
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookEmailOpenedPayload> 
     */
    open class func getTestWebhookPayloadEmailOpenedWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookEmailOpenedPayload> {
        let localVariablePath = "/webhooks/test/email-opened-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookEmailOpenedPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookEmailReadPayload>
     */
    open class func getTestWebhookPayloadEmailRead(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookEmailReadPayload> {
        let deferred = Promise<WebhookEmailReadPayload>.pending()
        getTestWebhookPayloadEmailReadWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - GET /webhooks/test/email-read-payload
     - Get webhook test payload for email opened event
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookEmailReadPayload> 
     */
    open class func getTestWebhookPayloadEmailReadWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookEmailReadPayload> {
        let localVariablePath = "/webhooks/test/email-read-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookEmailReadPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**

     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<AbstractWebhookPayload>
     */
    open class func getTestWebhookPayloadForWebhook(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<AbstractWebhookPayload> {
        let deferred = Promise<AbstractWebhookPayload>.pending()
        getTestWebhookPayloadForWebhookWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     - POST /webhooks/{webhookId}/example
     - Get example payload for webhook
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<AbstractWebhookPayload> 
     */
    open class func getTestWebhookPayloadForWebhookWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<AbstractWebhookPayload> {
        var localVariablePath = "/webhooks/{webhookId}/example"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<AbstractWebhookPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for new ai transform result event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookNewAITransformResultPayload>
     */
    open class func getTestWebhookPayloadNewAITransformResult(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookNewAITransformResultPayload> {
        let deferred = Promise<WebhookNewAITransformResultPayload>.pending()
        getTestWebhookPayloadNewAITransformResultWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for new ai transform result event
     - GET /webhooks/test/new-ai-transform-result-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookNewAITransformResultPayload> 
     */
    open class func getTestWebhookPayloadNewAITransformResultWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookNewAITransformResultPayload> {
        let localVariablePath = "/webhooks/test/new-ai-transform-result-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookNewAITransformResultPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for new attachment event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookNewAttachmentPayload>
     */
    open class func getTestWebhookPayloadNewAttachment(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookNewAttachmentPayload> {
        let deferred = Promise<WebhookNewAttachmentPayload>.pending()
        getTestWebhookPayloadNewAttachmentWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for new attachment event
     - GET /webhooks/test/new-attachment-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookNewAttachmentPayload> 
     */
    open class func getTestWebhookPayloadNewAttachmentWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookNewAttachmentPayload> {
        let localVariablePath = "/webhooks/test/new-attachment-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookNewAttachmentPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for new contact event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookNewContactPayload>
     */
    open class func getTestWebhookPayloadNewContact(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookNewContactPayload> {
        let deferred = Promise<WebhookNewContactPayload>.pending()
        getTestWebhookPayloadNewContactWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for new contact event
     - GET /webhooks/test/new-contact-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookNewContactPayload> 
     */
    open class func getTestWebhookPayloadNewContactWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookNewContactPayload> {
        let localVariablePath = "/webhooks/test/new-contact-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookNewContactPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for new email event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookNewEmailPayload>
     */
    open class func getTestWebhookPayloadNewEmail(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookNewEmailPayload> {
        let deferred = Promise<WebhookNewEmailPayload>.pending()
        getTestWebhookPayloadNewEmailWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for new email event
     - GET /webhooks/test/new-email-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookNewEmailPayload> 
     */
    open class func getTestWebhookPayloadNewEmailWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookNewEmailPayload> {
        let localVariablePath = "/webhooks/test/new-email-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookNewEmailPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get webhook test payload for new sms event
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookNewSmsPayload>
     */
    open class func getTestWebhookPayloadNewSms(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookNewSmsPayload> {
        let deferred = Promise<WebhookNewSmsPayload>.pending()
        getTestWebhookPayloadNewSmsWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get webhook test payload for new sms event
     - GET /webhooks/test/new-sms-payload
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookNewSmsPayload> 
     */
    open class func getTestWebhookPayloadNewSmsWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookNewSmsPayload> {
        let localVariablePath = "/webhooks/test/new-sms-payload"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookNewSmsPayload>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get a webhook
     
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func getWebhook(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        getWebhookWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a webhook
     - GET /webhooks/{webhookId}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func getWebhookWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/webhooks/{webhookId}"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get a webhook result for a webhook
     
     - parameter webhookResultId: (path) Webhook Result ID 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookResultDto>
     */
    open class func getWebhookResult(webhookResultId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookResultDto> {
        let deferred = Promise<WebhookResultDto>.pending()
        getWebhookResultWithRequestBuilder(webhookResultId: webhookResultId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a webhook result for a webhook
     - GET /webhooks/results/{webhookResultId}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookResultId: (path) Webhook Result ID 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookResultDto> 
     */
    open class func getWebhookResultWithRequestBuilder(webhookResultId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookResultDto> {
        var localVariablePath = "/webhooks/results/{webhookResultId}"
        let webhookResultIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookResultId))"
        let webhookResultIdPostEscape = webhookResultIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookResultId}", with: webhookResultIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookResultDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getWebhookResults: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     * enum for parameter resultType
     */
    public enum ResultType_getWebhookResults: String, Sendable, CaseIterable {
        case badResponse = "BAD_RESPONSE"
        case exception = "EXCEPTION"
        case success = "SUCCESS"
        case redriven = "REDRIVEN"
    }

    /**
     * enum for parameter eventName
     */
    public enum EventName_getWebhookResults: String, Sendable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newAiTransformResult = "NEW_AI_TRANSFORM_RESULT"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
        case deliveryStatus = "DELIVERY_STATUS"
        case bounce = "BOUNCE"
        case bounceRecipient = "BOUNCE_RECIPIENT"
        case newSms = "NEW_SMS"
        case newGuestUser = "NEW_GUEST_USER"
    }

    /**
     Get a webhook results for a webhook
     
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter unseenOnly: (query) Filter for unseen exceptions only (optional)
     - parameter resultType: (query) Filter by result type (optional)
     - parameter eventName: (query) Filter by event name (optional)
     - parameter minStatusCode: (query) Minimum response status (optional)
     - parameter maxStatusCode: (query) Maximum response status (optional)
     - parameter inboxId: (query) Inbox ID (optional)
     - parameter smsId: (query) Sms ID (optional)
     - parameter attachmentId: (query) Attachment ID (optional)
     - parameter emailId: (query) Email ID (optional)
     - parameter phoneId: (query) Phone ID (optional)
     - parameter aiTransformerId: (query) AI Transformer ID (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<PageWebhookResult>
     */
    open class func getWebhookResults(webhookId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getWebhookResults? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, unseenOnly: Bool? = nil, resultType: ResultType_getWebhookResults? = nil, eventName: EventName_getWebhookResults? = nil, minStatusCode: Int? = nil, maxStatusCode: Int? = nil, inboxId: UUID? = nil, smsId: UUID? = nil, attachmentId: UUID? = nil, emailId: UUID? = nil, phoneId: UUID? = nil, aiTransformerId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<PageWebhookResult> {
        let deferred = Promise<PageWebhookResult>.pending()
        getWebhookResultsWithRequestBuilder(webhookId: webhookId, page: page, size: size, sort: sort, searchFilter: searchFilter, since: since, before: before, unseenOnly: unseenOnly, resultType: resultType, eventName: eventName, minStatusCode: minStatusCode, maxStatusCode: maxStatusCode, inboxId: inboxId, smsId: smsId, attachmentId: attachmentId, emailId: emailId, phoneId: phoneId, aiTransformerId: aiTransformerId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a webhook results for a webhook
     - GET /webhooks/{webhookId}/results
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter searchFilter: (query) Optional search filter (optional)
     - parameter since: (query) Filter by created at after the given timestamp (optional)
     - parameter before: (query) Filter by created at before the given timestamp (optional)
     - parameter unseenOnly: (query) Filter for unseen exceptions only (optional)
     - parameter resultType: (query) Filter by result type (optional)
     - parameter eventName: (query) Filter by event name (optional)
     - parameter minStatusCode: (query) Minimum response status (optional)
     - parameter maxStatusCode: (query) Maximum response status (optional)
     - parameter inboxId: (query) Inbox ID (optional)
     - parameter smsId: (query) Sms ID (optional)
     - parameter attachmentId: (query) Attachment ID (optional)
     - parameter emailId: (query) Email ID (optional)
     - parameter phoneId: (query) Phone ID (optional)
     - parameter aiTransformerId: (query) AI Transformer ID (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<PageWebhookResult> 
     */
    open class func getWebhookResultsWithRequestBuilder(webhookId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getWebhookResults? = nil, searchFilter: String? = nil, since: Date? = nil, before: Date? = nil, unseenOnly: Bool? = nil, resultType: ResultType_getWebhookResults? = nil, eventName: EventName_getWebhookResults? = nil, minStatusCode: Int? = nil, maxStatusCode: Int? = nil, inboxId: UUID? = nil, smsId: UUID? = nil, attachmentId: UUID? = nil, emailId: UUID? = nil, phoneId: UUID? = nil, aiTransformerId: UUID? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<PageWebhookResult> {
        var localVariablePath = "/webhooks/{webhookId}/results"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "searchFilter": (wrappedValue: searchFilter?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "since": (wrappedValue: since?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "before": (wrappedValue: before?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "unseenOnly": (wrappedValue: unseenOnly?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "resultType": (wrappedValue: resultType?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "eventName": (wrappedValue: eventName?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "minStatusCode": (wrappedValue: minStatusCode?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "maxStatusCode": (wrappedValue: maxStatusCode?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "smsId": (wrappedValue: smsId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "attachmentId": (wrappedValue: attachmentId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "emailId": (wrappedValue: emailId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "phoneId": (wrappedValue: phoneId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "aiTransformerId": (wrappedValue: aiTransformerId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<PageWebhookResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get a webhook results count for a webhook
     
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<CountDto>
     */
    open class func getWebhookResultsCount(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<CountDto> {
        let deferred = Promise<CountDto>.pending()
        getWebhookResultsCountWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a webhook results count for a webhook
     - GET /webhooks/{webhookId}/results/count
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<CountDto> 
     */
    open class func getWebhookResultsCountWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<CountDto> {
        var localVariablePath = "/webhooks/{webhookId}/results/count"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<CountDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get count of unseen webhook results with error status
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<UnseenErrorCountDto>
     */
    open class func getWebhookResultsUnseenErrorCount(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<UnseenErrorCountDto> {
        let deferred = Promise<UnseenErrorCountDto>.pending()
        getWebhookResultsUnseenErrorCountWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get count of unseen webhook results with error status
     - GET /webhooks/results/unseen-count
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<UnseenErrorCountDto> 
     */
    open class func getWebhookResultsUnseenErrorCountWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<UnseenErrorCountDto> {
        let localVariablePath = "/webhooks/results/unseen-count"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<UnseenErrorCountDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getWebhooks: String, Sendable, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all webhooks for an Inbox
     
     - parameter inboxId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<[WebhookProjection]>
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getWebhooks(inboxId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getWebhooks? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<[WebhookProjection]> {
        let deferred = Promise<[WebhookProjection]>.pending()
        getWebhooksWithRequestBuilder(inboxId: inboxId, page: page, size: size, sort: sort, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all webhooks for an Inbox
     - GET /inboxes/{inboxId}/webhooks
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter inboxId: (path)  
     - parameter page: (query) Optional page index in list pagination (optional, default to 0)
     - parameter size: (query) Optional page size in list pagination (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[WebhookProjection]> 
     */
    @available(*, deprecated, message: "This operation is deprecated.")
    open class func getWebhooksWithRequestBuilder(inboxId: UUID, page: Int? = nil, size: Int? = nil, sort: Sort_getWebhooks? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<[WebhookProjection]> {
        var localVariablePath = "/inboxes/{inboxId}/webhooks"
        let inboxIdPreEscape = "\(APIHelper.mapValueToPathItem(inboxId))"
        let inboxIdPostEscape = inboxIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{inboxId}", with: inboxIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "page": (wrappedValue: page?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "size": (wrappedValue: size?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "sort": (wrappedValue: sort?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[WebhookProjection]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Redrive all webhook results that have failed status
     
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookRedriveAllResult>
     */
    open class func redriveAllWebhookResults(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookRedriveAllResult> {
        let deferred = Promise<WebhookRedriveAllResult>.pending()
        redriveAllWebhookResultsWithRequestBuilder(apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Redrive all webhook results that have failed status
     - POST /webhooks/results/redrive
     - Allows you to resend webhook payloads for any recorded webhook result that failed to deliver the payload.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookRedriveAllResult> 
     */
    open class func redriveAllWebhookResultsWithRequestBuilder(apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookRedriveAllResult> {
        let localVariablePath = "/webhooks/results/redrive"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookRedriveAllResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Get a webhook result and try to resend the original webhook payload
     
     - parameter webhookResultId: (path) Webhook Result ID 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookRedriveResult>
     */
    open class func redriveWebhookResult(webhookResultId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookRedriveResult> {
        let deferred = Promise<WebhookRedriveResult>.pending()
        redriveWebhookResultWithRequestBuilder(webhookResultId: webhookResultId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a webhook result and try to resend the original webhook payload
     - POST /webhooks/results/{webhookResultId}/redrive
     - Allows you to resend a webhook payload that was already sent. Webhooks that fail are retried automatically for 24 hours and then put in a dead letter queue. You can retry results manually using this method.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookResultId: (path) Webhook Result ID 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookRedriveResult> 
     */
    open class func redriveWebhookResultWithRequestBuilder(webhookResultId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookRedriveResult> {
        var localVariablePath = "/webhooks/results/{webhookResultId}/redrive"
        let webhookResultIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookResultId))"
        let webhookResultIdPostEscape = webhookResultIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookResultId}", with: webhookResultIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookRedriveResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Send webhook test data
     
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookTestResult>
     */
    open class func sendTestData(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookTestResult> {
        let deferred = Promise<WebhookTestResult>.pending()
        sendTestDataWithRequestBuilder(webhookId: webhookId, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send webhook test data
     - POST /webhooks/{webhookId}/test
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookTestResult> 
     */
    open class func sendTestDataWithRequestBuilder(webhookId: UUID, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookTestResult> {
        var localVariablePath = "/webhooks/{webhookId}/test"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookTestResult>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Update a webhook
     
     - parameter webhookId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter inboxId: (query)  (optional)
     - parameter aiTransformerId: (query)  (optional)
     - parameter phoneNumberId: (query)  (optional)
     - parameter overrideAuth: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func updateWebhook(webhookId: UUID, createWebhookOptions: CreateWebhookOptions, inboxId: UUID? = nil, aiTransformerId: UUID? = nil, phoneNumberId: UUID? = nil, overrideAuth: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        updateWebhookWithRequestBuilder(webhookId: webhookId, createWebhookOptions: createWebhookOptions, inboxId: inboxId, aiTransformerId: aiTransformerId, phoneNumberId: phoneNumberId, overrideAuth: overrideAuth, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update a webhook
     - PATCH /webhooks/{webhookId}
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter createWebhookOptions: (body)  
     - parameter inboxId: (query)  (optional)
     - parameter aiTransformerId: (query)  (optional)
     - parameter phoneNumberId: (query)  (optional)
     - parameter overrideAuth: (query)  (optional)
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func updateWebhookWithRequestBuilder(webhookId: UUID, createWebhookOptions: CreateWebhookOptions, inboxId: UUID? = nil, aiTransformerId: UUID? = nil, phoneNumberId: UUID? = nil, overrideAuth: Bool? = nil, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/webhooks/{webhookId}"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: createWebhookOptions, codableHelper: apiConfiguration.codableHelper)

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": (wrappedValue: inboxId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "aiTransformerId": (wrappedValue: aiTransformerId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "phoneNumberId": (wrappedValue: phoneNumberId?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "overrideAuth": (wrappedValue: overrideAuth?.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PATCH", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Update a webhook request headers
     
     - parameter webhookId: (path)  
     - parameter webhookHeaders: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<WebhookDto>
     */
    open class func updateWebhookHeaders(webhookId: UUID, webhookHeaders: WebhookHeaders, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<WebhookDto> {
        let deferred = Promise<WebhookDto>.pending()
        updateWebhookHeadersWithRequestBuilder(webhookId: webhookId, webhookHeaders: webhookHeaders, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update a webhook request headers
     - PUT /webhooks/{webhookId}/headers
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path)  
     - parameter webhookHeaders: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<WebhookDto> 
     */
    open class func updateWebhookHeadersWithRequestBuilder(webhookId: UUID, webhookHeaders: WebhookHeaders, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<WebhookDto> {
        var localVariablePath = "/webhooks/{webhookId}/headers"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: webhookHeaders, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<WebhookDto>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "PUT", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Verify a webhook payload signature
     
     - parameter verifyWebhookSignatureOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<VerifyWebhookSignatureResults>
     */
    open class func verifyWebhookSignature(verifyWebhookSignatureOptions: VerifyWebhookSignatureOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<VerifyWebhookSignatureResults> {
        let deferred = Promise<VerifyWebhookSignatureResults>.pending()
        verifyWebhookSignatureWithRequestBuilder(verifyWebhookSignatureOptions: verifyWebhookSignatureOptions, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Verify a webhook payload signature
     - POST /webhooks/verify
     - Verify a webhook payload using the messageId and signature. This allows you to be sure that MailSlurp sent the payload and not another server.
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter verifyWebhookSignatureOptions: (body)  
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<VerifyWebhookSignatureResults> 
     */
    open class func verifyWebhookSignatureWithRequestBuilder(verifyWebhookSignatureOptions: VerifyWebhookSignatureOptions, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<VerifyWebhookSignatureResults> {
        let localVariablePath = "/webhooks/verify"
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters = JSONEncodingHelper.encodingParameters(forEncodableObject: verifyWebhookSignatureOptions, codableHelper: apiConfiguration.codableHelper)

        let localVariableUrlComponents = URLComponents(string: localVariableURLString)

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            "Content-Type": "application/json",
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<VerifyWebhookSignatureResults>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "POST", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }

    /**
     Wait for webhook results for a webhook
     
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter expectedCount: (query) Expected result count 
     - parameter timeout: (query) Max time to wait in milliseconds 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: Promise<[WebhookResultDto]>
     */
    open class func waitForWebhookResults(webhookId: UUID, expectedCount: Int, timeout: Int, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> Promise<[WebhookResultDto]> {
        let deferred = Promise<[WebhookResultDto]>.pending()
        waitForWebhookResultsWithRequestBuilder(webhookId: webhookId, expectedCount: expectedCount, timeout: timeout, apiConfiguration: apiConfiguration).execute { result in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Wait for webhook results for a webhook
     - GET /webhooks/{webhookId}/wait
     - API Key:
       - type: apiKey x-api-key (HEADER)
       - name: API_KEY
     - parameter webhookId: (path) ID of webhook to get results for 
     - parameter expectedCount: (query) Expected result count 
     - parameter timeout: (query) Max time to wait in milliseconds 
     - parameter apiConfiguration: The configuration for the http request.
     - returns: RequestBuilder<[WebhookResultDto]> 
     */
    open class func waitForWebhookResultsWithRequestBuilder(webhookId: UUID, expectedCount: Int, timeout: Int, apiConfiguration: mailslurpAPIConfiguration = mailslurpAPIConfiguration.shared) -> RequestBuilder<[WebhookResultDto]> {
        var localVariablePath = "/webhooks/{webhookId}/wait"
        let webhookIdPreEscape = "\(APIHelper.mapValueToPathItem(webhookId))"
        let webhookIdPostEscape = webhookIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        localVariablePath = localVariablePath.replacingOccurrences(of: "{webhookId}", with: webhookIdPostEscape, options: .literal, range: nil)
        let localVariableURLString = apiConfiguration.basePath + localVariablePath
        let localVariableParameters: [String: any Sendable]? = nil

        var localVariableUrlComponents = URLComponents(string: localVariableURLString)
        localVariableUrlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "expectedCount": (wrappedValue: expectedCount.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
            "timeout": (wrappedValue: timeout.asParameter(codableHelper: apiConfiguration.codableHelper), isExplode: true),
        ])

        let localVariableNillableHeaders: [String: (any Sendable)?] = [
            :
        ]

        let localVariableHeaderParameters = APIHelper.rejectNilHeaders(localVariableNillableHeaders)

        let localVariableRequestBuilder: RequestBuilder<[WebhookResultDto]>.Type = apiConfiguration.requestBuilderFactory.getBuilder()

        return localVariableRequestBuilder.init(method: "GET", URLString: (localVariableUrlComponents?.string ?? localVariableURLString), parameters: localVariableParameters, headers: localVariableHeaderParameters, requiresAuthentication: true, apiConfiguration: apiConfiguration)
    }
}
