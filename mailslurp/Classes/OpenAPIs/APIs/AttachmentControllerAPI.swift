//
// AttachmentControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation



@objc open class AttachmentControllerAPI : NSObject {
    /**
     Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func downloadAttachmentAsBase64Encoded(attachmentId: String, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: DownloadAttachmentDto?,_ error: Error?) -> Void)) {
        downloadAttachmentAsBase64EncodedWithRequestBuilder(attachmentId: attachmentId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get email attachment as base64 encoded string as alternative to binary responses. To read the content decode the Base64 encoded contents.
     - GET /attachments/{attachmentId}/base64
     - Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<DownloadAttachmentDto> 
     */
    open class func downloadAttachmentAsBase64EncodedWithRequestBuilder(attachmentId: String) -> RequestBuilder<DownloadAttachmentDto> {
        var path = "/attachments/{attachmentId}/base64"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<DownloadAttachmentDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func downloadAttachmentAsBytes(attachmentId: String, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: Data?,_ error: Error?) -> Void)) {
        downloadAttachmentAsBytesWithRequestBuilder(attachmentId: attachmentId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Download attachments. Get email attachment bytes. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints.
     - GET /attachments/{attachmentId}/bytes
     - Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<Data> 
     */
    open class func downloadAttachmentAsBytesWithRequestBuilder(attachmentId: String) -> RequestBuilder<Data> {
        var path = "/attachments/{attachmentId}/bytes"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<Data>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Get email attachment metadata information
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func getAttachmentInfo(attachmentId: String, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: AttachmentMetaData?,_ error: Error?) -> Void)) {
        getAttachmentInfoWithRequestBuilder(attachmentId: attachmentId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Get email attachment metadata information
     - GET /attachments/{attachmentId}/metadata
     - Returns the metadata for an attachment. It is saved separately to the content of the attachment. Contains properties `name` and `content-type` and `content-length` in bytes for a given attachment.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - returns: RequestBuilder<AttachmentMetaData> 
     */
    open class func getAttachmentInfoWithRequestBuilder(attachmentId: String) -> RequestBuilder<AttachmentMetaData> {
        var path = "/attachments/{attachmentId}/metadata"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String:Any]? = nil
        
        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<AttachmentMetaData>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

    /**
     Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter uploadOptions: (body) uploadOptions 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func uploadAttachment(uploadOptions: UploadAttachmentOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?,_ error: Error?) -> Void)) {
        uploadAttachmentWithRequestBuilder(uploadOptions: uploadOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Upload an attachment for sending using base64 file encoding. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments
     - Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter uploadOptions: (body) uploadOptions 
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadAttachmentWithRequestBuilder(uploadOptions: UploadAttachmentOptions) -> RequestBuilder<[String]> {
        let path = "/attachments"
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: uploadOptions)

        let url = URLComponents(string: URLString)

        let requestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter string: (query) Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)
     - parameter filename: (query) Optional filename to save upload with (optional)
     - parameter byteArray: (body) Byte array request body (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func uploadAttachmentBytes(string: String? = nil, filename: String? = nil, byteArray: Data? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?,_ error: Error?) -> Void)) {
        uploadAttachmentBytesWithRequestBuilder(string: string, filename: filename, byteArray: byteArray).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Upload an attachment for sending using file byte stream input octet stream. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments/bytes
     - Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter string: (query) Optional contentType for file. For instance &#x60;application/pdf&#x60; (optional)
     - parameter filename: (query) Optional filename to save upload with (optional)
     - parameter byteArray: (body) Byte array request body (optional)
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadAttachmentBytesWithRequestBuilder(string: String? = nil, filename: String? = nil, byteArray: Data? = nil) -> RequestBuilder<[String]> {
        let path = "/attachments/bytes"
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: byteArray)

        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "String": string?.encodeToJSON(), 
            "filename": filename?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: true)
    }

    /**
     Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     
     - parameter file: (form) file 
     - parameter contentType: (query) Optional content type of attachment (optional)
     - parameter filename: (query) Optional name of file (optional)
     - parameter xFilename: (query) Optional content type header of attachment (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - parameter completion: completion handler to receive the data and the error objects
     */
    open class func uploadMultipartForm(file: URL, contentType: String? = nil, filename: String? = nil, xFilename: String? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue, completion: @escaping ((_ data: [String]?,_ error: Error?) -> Void)) {
        uploadMultipartFormWithRequestBuilder(file: file, contentType: contentType, filename: filename, xFilename: xFilename).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                completion(response.body, nil)
            case let .failure(error):
                completion(nil, error)
            }
        }
    }

    /**
     Upload an attachment for sending using a Multipart Form request. Returns an array whose first element is the ID of the uploaded attachment.
     - POST /attachments/multipart
     - Email attachments are essentially files with meta data. Files are byte arrays and the meta data is a content type and a filename. These properties allow email clients to display the filename and icon etc. When sending emails with attachments first upload each attachment with an upload endpoint. Record the returned attachment ID and use it with subsequent email sending. For legacy reasons the ID is returned as the first element in an array. Only a single ID is ever returned. To send the attachments pass a list of attachment IDs with `SendEmailOptions` when sending an email. Using the upload endpoints prior to sending mean attachments can easily be reused.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter file: (form) file 
     - parameter contentType: (query) Optional content type of attachment (optional)
     - parameter filename: (query) Optional name of file (optional)
     - parameter xFilename: (query) Optional content type header of attachment (optional)
     - returns: RequestBuilder<[String]> 
     */
    open class func uploadMultipartFormWithRequestBuilder(file: URL, contentType: String? = nil, filename: String? = nil, xFilename: String? = nil) -> RequestBuilder<[String]> {
        let path = "/attachments/multipart"
        let URLString = mailslurpAPI.basePath + path
        let formParams: [String:Any?] = [
            "file": file.encodeToJSON()
        ]

        let nonNullParameters = APIHelper.rejectNil(formParams)
        let parameters = APIHelper.convertBoolToString(nonNullParameters)
        
        var url = URLComponents(string: URLString)
        url?.queryItems = APIHelper.mapValuesToQueryItems([
            "contentType": contentType?.encodeToJSON(), 
            "filename": filename?.encodeToJSON(), 
            "x-filename": xFilename?.encodeToJSON()
        ])

        let requestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, isBody: false)
    }

}
