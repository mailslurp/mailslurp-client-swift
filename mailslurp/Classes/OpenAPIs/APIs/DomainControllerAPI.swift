//
// DomainControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import PromiseKit

@objc open class DomainControllerAPI : NSObject {
    /**
     Add catch all wild card inbox to domain
     
     - parameter _id: (path) id 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<DomainDto>
     */
    open class func addDomainWildcardCatchAll( _id: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<DomainDto> {
        let deferred = Promise<DomainDto>.pending()
        addDomainWildcardCatchAllWithRequestBuilder(_id: _id).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Add catch all wild card inbox to domain
     - POST /domains/{id}/wildcard
     - Add a catch all inbox to a domain so that any emails sent to it that cannot be matched will be sent to the catch all inbox generated
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter _id: (path) id 
     - returns: RequestBuilder<DomainDto> 
     */
    open class func addDomainWildcardCatchAllWithRequestBuilder(_id: UUID) -> RequestBuilder<DomainDto> {
        var path = "/domains/{id}/wildcard"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<DomainDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Create Domain
     
     - parameter domainOptions: (body) domainOptions 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<DomainDto>
     */
    open class func createDomain( domainOptions: CreateDomainOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<DomainDto> {
        let deferred = Promise<DomainDto>.pending()
        createDomainWithRequestBuilder(domainOptions: domainOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Create Domain
     - POST /domains
     - Link a domain that you own with MailSlurp so you can create email addresses using it. Endpoint returns DNS records used for validation. You must add these verification records to your host provider's DNS setup to verify the domain.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter domainOptions: (body) domainOptions 
     - returns: RequestBuilder<DomainDto> 
     */
    open class func createDomainWithRequestBuilder(domainOptions: CreateDomainOptions) -> RequestBuilder<DomainDto> {
        let path = "/domains"
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: domainOptions)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<DomainDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete a domain
     
     - parameter _id: (path) id 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<[String]>
     */
    open class func deleteDomain( _id: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<[String]> {
        let deferred = Promise<[String]>.pending()
        deleteDomainWithRequestBuilder(_id: _id).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete a domain
     - DELETE /domains/{id}
     - Delete a domain. This will disable any existing inboxes that use this domain.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter _id: (path) id 
     - returns: RequestBuilder<[String]> 
     */
    open class func deleteDomainWithRequestBuilder(_id: UUID) -> RequestBuilder<[String]> {
        var path = "/domains/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<[String]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get a domain
     
     - parameter _id: (path) id 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<DomainDto>
     */
    open class func getDomain( _id: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<DomainDto> {
        let deferred = Promise<DomainDto>.pending()
        getDomainWithRequestBuilder(_id: _id).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get a domain
     - GET /domains/{id}
     - Returns domain verification status and tokens for a given domain
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter _id: (path) id 
     - returns: RequestBuilder<DomainDto> 
     */
    open class func getDomainWithRequestBuilder(_id: UUID) -> RequestBuilder<DomainDto> {
        var path = "/domains/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<DomainDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get domains
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<[DomainPreview]>
     */
    open class func getDomains(apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<[DomainPreview]> {
        let deferred = Promise<[DomainPreview]>.pending()
        getDomainsWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get domains
     - GET /domains
     - List all custom domains you have created
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<[DomainPreview]> 
     */
    open class func getDomainsWithRequestBuilder() -> RequestBuilder<[DomainPreview]> {
        let path = "/domains"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<[DomainPreview]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Update a domain
     
     - parameter _id: (path) id 
     - parameter updateDomainDto: (body) updateDomainDto 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<DomainDto>
     */
    open class func updateDomain( _id: UUID,  updateDomainDto: UpdateDomainOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<DomainDto> {
        let deferred = Promise<DomainDto>.pending()
        updateDomainWithRequestBuilder(_id: _id, updateDomainDto: updateDomainDto).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Update a domain
     - PUT /domains/{id}
     - Update values on a domain. Note you cannot change the domain name as it is immutable. Recreate the domain if you need to alter this.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter _id: (path) id 
     - parameter updateDomainDto: (body) updateDomainDto 
     - returns: RequestBuilder<DomainDto> 
     */
    open class func updateDomainWithRequestBuilder(_id: UUID, updateDomainDto: UpdateDomainOptions) -> RequestBuilder<DomainDto> {
        var path = "/domains/{id}"
        let _idPreEscape = "\(APIHelper.mapValueToPathItem(_id))"
        let _idPostEscape = _idPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{id}", with: _idPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: updateDomainDto)

        let url = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<DomainDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (url?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
