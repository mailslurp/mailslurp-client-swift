//
// EmailControllerAPI.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import PromiseKit

@objc open class EmailControllerAPI : NSObject {
    /**
     Delete all emails in all inboxes.
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Void>
     */
    open class func deleteAllEmails(apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteAllEmailsWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete all emails in all inboxes.
     - DELETE /emails
     - Deletes all emails in your account. Be careful as emails cannot be recovered
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<Void> 
     */
    open class func deleteAllEmailsWithRequestBuilder() -> RequestBuilder<Void> {
        let path = "/emails"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Delete an email
     
     - parameter emailId: (path) ID of email to delete 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Void>
     */
    open class func deleteEmail( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        deleteEmailWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Delete an email
     - DELETE /emails/{emailId}
     - Deletes an email and removes it from the inbox. Deleted emails cannot be recovered.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email to delete 
     - returns: RequestBuilder<Void> 
     */
    open class func deleteEmailWithRequestBuilder(emailId: UUID) -> RequestBuilder<Void> {
        var path = "/emails/{emailId}"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "DELETE", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - parameter apiKey: (query) Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Data>
     */
    open class func downloadAttachment( attachmentId: String,  emailId: UUID,  apiKey: String? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Data> {
        let deferred = Promise<Data>.pending()
        downloadAttachmentWithRequestBuilder(attachmentId: attachmentId, emailId: emailId, apiKey: apiKey).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachment bytes. Returned as `octet-stream` with content type header. If you have trouble with byte responses try the `downloadAttachmentBase64` response endpoints and convert the base 64 encoded content to a file or string.
     - GET /emails/{emailId}/attachments/{attachmentId}
     - Returns the specified attachment for a given email as a stream / array of bytes. You can find attachment ids in email responses endpoint responses. The response type is application/octet-stream.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - parameter apiKey: (query) Can pass apiKey in url for this request if you wish to download the file in a browser. Content type will be set to original content type of the attachment file. This is so that browsers can download the file correctly. (optional)
     - returns: RequestBuilder<Data> 
     */
    open class func downloadAttachmentWithRequestBuilder(attachmentId: String, emailId: UUID, apiKey: String? = nil) -> RequestBuilder<Data> {
        var path = "/emails/{emailId}/attachments/{attachmentId}"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "apiKey": apiKey?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Data>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<DownloadAttachmentDto>
     */
    open class func downloadAttachmentBase64( attachmentId: String,  emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<DownloadAttachmentDto> {
        let deferred = Promise<DownloadAttachmentDto>.pending()
        downloadAttachmentBase64WithRequestBuilder(attachmentId: attachmentId, emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachment as base64 encoded string as an alternative to binary responses. Decode the `base64FileContents` as a `utf-8` encoded string or array of bytes depending on the `contentType`.
     - GET /emails/{emailId}/attachments/{attachmentId}/base64
     - Returns the specified attachment for a given email as a base 64 encoded string. The response type is application/json. This method is similar to the `downloadAttachment` method but allows some clients to get around issues with binary responses.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<DownloadAttachmentDto> 
     */
    open class func downloadAttachmentBase64WithRequestBuilder(attachmentId: String, emailId: UUID) -> RequestBuilder<DownloadAttachmentDto> {
        var path = "/emails/{emailId}/attachments/{attachmentId}/base64"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<DownloadAttachmentDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email body as string. Returned as `plain/text` with content type header.
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<String>
     */
    open class func downloadBody( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<String> {
        let deferred = Promise<String>.pending()
        downloadBodyWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email body as string. Returned as `plain/text` with content type header.
     - GET /emails/{emailId}/body
     - Returns the specified email body for a given email as a string
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<String> 
     */
    open class func downloadBodyWithRequestBuilder(emailId: UUID) -> RequestBuilder<String> {
        var path = "/emails/{emailId}/body"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<String>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email body in bytes. Returned as `octet-stream` with content type header.
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Data>
     */
    open class func downloadBodyBytes( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Data> {
        let deferred = Promise<Data>.pending()
        downloadBodyBytesWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email body in bytes. Returned as `octet-stream` with content type header.
     - GET /emails/{emailId}/body-bytes
     - Returns the specified email body for a given email as a stream / array of bytes.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<Data> 
     */
    open class func downloadBodyBytesWithRequestBuilder(emailId: UUID) -> RequestBuilder<Data> {
        var path = "/emails/{emailId}/body-bytes"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Data>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Forward email to recipients
     
     - parameter emailId: (path) ID of email 
     - parameter forwardEmailOptions: (body) forwardEmailOptions 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Void>
     */
    open class func forwardEmail( emailId: UUID,  forwardEmailOptions: ForwardEmailOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        forwardEmailWithRequestBuilder(emailId: emailId, forwardEmailOptions: forwardEmailOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Forward email to recipients
     - POST /emails/{emailId}/forward
     - Forward an existing email to new recipients. The sender of the email will be the inbox that received the email you are forwarding. You can override the sender with the `from` option. Note you must have access to the from address in MailSlurp to use the override. For more control consider fetching the email and sending it a new using the send email endpoints.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - parameter forwardEmailOptions: (body) forwardEmailOptions 
     - returns: RequestBuilder<Void> 
     */
    open class func forwardEmailWithRequestBuilder(emailId: UUID, forwardEmailOptions: ForwardEmailOptions) -> RequestBuilder<Void> {
        var path = "/emails/{emailId}/forward"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: forwardEmailOptions)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
     
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<AttachmentMetaData>
     */
    open class func getAttachmentMetaData( attachmentId: String,  emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<AttachmentMetaData> {
        let deferred = Promise<AttachmentMetaData>.pending()
        getAttachmentMetaDataWithRequestBuilder(attachmentId: attachmentId, emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email attachment metadata. This is the `contentType` and `contentLength` of an attachment. To get the individual attachments  use the `downloadAttachment` methods.
     - GET /emails/{emailId}/attachments/{attachmentId}/metadata
     - Returns the metadata such as name and content-type for a given attachment and email.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter attachmentId: (path) ID of attachment 
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<AttachmentMetaData> 
     */
    open class func getAttachmentMetaDataWithRequestBuilder(attachmentId: String, emailId: UUID) -> RequestBuilder<AttachmentMetaData> {
        var path = "/emails/{emailId}/attachments/{attachmentId}/metadata"
        let attachmentIdPreEscape = "\(APIHelper.mapValueToPathItem(attachmentId))"
        let attachmentIdPostEscape = attachmentIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{attachmentId}", with: attachmentIdPostEscape, options: .literal, range: nil)
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<AttachmentMetaData>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get all email attachment metadata. Metadata includes name and size of attachments.
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<[AttachmentMetaData]>
     */
    open class func getAttachments1( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<[AttachmentMetaData]> {
        let deferred = Promise<[AttachmentMetaData]>.pending()
        getAttachments1WithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all email attachment metadata. Metadata includes name and size of attachments.
     - GET /emails/{emailId}/attachments
     - Returns an array of attachment metadata such as name and content-type for a given email if present.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<[AttachmentMetaData]> 
     */
    open class func getAttachments1WithRequestBuilder(emailId: UUID) -> RequestBuilder<[AttachmentMetaData]> {
        var path = "/emails/{emailId}/attachments"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<[AttachmentMetaData]>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
     
     - parameter emailId: (path) emailId 
     - parameter decode: (query) Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Email>
     */
    open class func getEmail( emailId: UUID,  decode: Bool? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Email> {
        let deferred = Promise<Email>.pending()
        getEmailWithRequestBuilder(emailId: emailId, decode: decode).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email content including headers and body. Expects email to exist by ID. For emails that may not have arrived yet use the WaitForController.
     - GET /emails/{emailId}
     - Returns a email summary object with headers and content. To retrieve the raw unparsed email use the getRawEmail endpoints
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) emailId 
     - parameter decode: (query) Decode email body quoted-printable encoding to plain text. SMTP servers often encode text using quoted-printable format (for instance &#x60;&#x3D;D7&#x60;). This can be a pain for testing (optional, default to false)
     - returns: RequestBuilder<Email> 
     */
    open class func getEmailWithRequestBuilder(emailId: UUID, decode: Bool? = nil) -> RequestBuilder<Email> {
        var path = "/emails/{emailId}"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "decode": decode?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Email>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email content regex pattern match results. Runs regex against email body and returns match groups.
     
     - parameter emailId: (path) ID of email to match against 
     - parameter contentMatchOptions: (body) contentMatchOptions 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<EmailContentMatchResult>
     */
    open class func getEmailContentMatch( emailId: UUID,  contentMatchOptions: ContentMatchOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<EmailContentMatchResult> {
        let deferred = Promise<EmailContentMatchResult>.pending()
        getEmailContentMatchWithRequestBuilder(emailId: emailId, contentMatchOptions: contentMatchOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email content regex pattern match results. Runs regex against email body and returns match groups.
     - POST /emails/{emailId}/contentMatch
     - Return the matches for a given Java style regex pattern. Do not include the typical `/` at start or end of regex in some languages. Given an example `your code is: 12345` the pattern to extract match looks like `code is: (\\d{6})`. This will return an array of matches with the first matching the entire pattern and the subsequent matching the groups: `['code is: 123456', '123456']` See https://docs.oracle.com/javase/8/docs/api/java/util/regex/Pattern.html for more information of available patterns. 
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email to match against 
     - parameter contentMatchOptions: (body) contentMatchOptions 
     - returns: RequestBuilder<EmailContentMatchResult> 
     */
    open class func getEmailContentMatchWithRequestBuilder(emailId: UUID, contentMatchOptions: ContentMatchOptions) -> RequestBuilder<EmailContentMatchResult> {
        var path = "/emails/{emailId}/contentMatch"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: contentMatchOptions)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<EmailContentMatchResult>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get email content as HTML. For displaying emails in browser context.
     
     - parameter emailId: (path) emailId 
     - parameter decode: (query) decode (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<String>
     */
    open class func getEmailHTML( emailId: UUID,  decode: Bool? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<String> {
        let deferred = Promise<String>.pending()
        getEmailHTMLWithRequestBuilder(emailId: emailId, decode: decode).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get email content as HTML. For displaying emails in browser context.
     - GET /emails/{emailId}/html
     - Retrieve email content as HTML response for viewing in browsers. Decodes quoted-printable entities and converts charset to UTF-8. Pass your API KEY as a request parameter when viewing in a browser: `?apiKey=xxx`
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) emailId 
     - parameter decode: (query) decode (optional, default to false)
     - returns: RequestBuilder<String> 
     */
    open class func getEmailHTMLWithRequestBuilder(emailId: UUID, decode: Bool? = nil) -> RequestBuilder<String> {
        var path = "/emails/{emailId}/html"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "decode": decode?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<String>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Parse and return text from an email, stripping HTML and decoding encoded characters
     
     - parameter emailId: (path) ID of email to perform HTML query on 
     - parameter htmlSelector: (query) HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information. (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<EmailTextLinesResult>
     */
    open class func getEmailHTMLQuery( emailId: UUID,  htmlSelector: String? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<EmailTextLinesResult> {
        let deferred = Promise<EmailTextLinesResult>.pending()
        getEmailHTMLQueryWithRequestBuilder(emailId: emailId, htmlSelector: htmlSelector).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Parse and return text from an email, stripping HTML and decoding encoded characters
     - GET /emails/{emailId}/htmlQuery
     - Parse an email body and return the content as an array of text. HTML parsing uses JSoup which supports JQuery/CSS style selectors
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email to perform HTML query on 
     - parameter htmlSelector: (query) HTML selector to search for. Uses JQuery/JSoup/CSS style selector like &#39;.my-div&#39; to match content. See https://jsoup.org/apidocs/org/jsoup/select/Selector.html for more information. (optional)
     - returns: RequestBuilder<EmailTextLinesResult> 
     */
    open class func getEmailHTMLQueryWithRequestBuilder(emailId: UUID, htmlSelector: String? = nil) -> RequestBuilder<EmailTextLinesResult> {
        var path = "/emails/{emailId}/htmlQuery"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "htmlSelector": htmlSelector?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<EmailTextLinesResult>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Parse and return text from an email, stripping HTML and decoding encoded characters
     
     - parameter emailId: (path) ID of email to fetch text for 
     - parameter decodeHtmlEntities: (query) Decode HTML entities (optional)
     - parameter lineSeparator: (query) Line separator character (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<EmailTextLinesResult>
     */
    open class func getEmailTextLines( emailId: UUID,  decodeHtmlEntities: Bool? = nil,  lineSeparator: String? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<EmailTextLinesResult> {
        let deferred = Promise<EmailTextLinesResult>.pending()
        getEmailTextLinesWithRequestBuilder(emailId: emailId, decodeHtmlEntities: decodeHtmlEntities, lineSeparator: lineSeparator).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Parse and return text from an email, stripping HTML and decoding encoded characters
     - GET /emails/{emailId}/textLines
     - Parse an email body and return the content as an array of strings. HTML parsing uses JSoup and UNIX line separators.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email to fetch text for 
     - parameter decodeHtmlEntities: (query) Decode HTML entities (optional)
     - parameter lineSeparator: (query) Line separator character (optional)
     - returns: RequestBuilder<EmailTextLinesResult> 
     */
    open class func getEmailTextLinesWithRequestBuilder(emailId: UUID, decodeHtmlEntities: Bool? = nil, lineSeparator: String? = nil) -> RequestBuilder<EmailTextLinesResult> {
        var path = "/emails/{emailId}/textLines"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "decodeHtmlEntities": decodeHtmlEntities?.encodeToJSON(),
            "lineSeparator": lineSeparator?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<EmailTextLinesResult>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getEmailsPaginated: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all emails in all inboxes in paginated form. Email API list all.
     
     - parameter inboxId: (query) Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
     - parameter page: (query) Optional page index in email list pagination (optional, default to 0)
     - parameter searchFilter: (query) Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional, default to "false")
     - parameter size: (query) Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<PageEmailProjection>
     */
    open class func getEmailsPaginated( inboxId: [UUID]? = nil,  page: Int? = nil,  searchFilter: String? = nil,  size: Int? = nil,  sort: Sort_getEmailsPaginated? = nil,  unreadOnly: Bool? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<PageEmailProjection> {
        let deferred = Promise<PageEmailProjection>.pending()
        getEmailsPaginatedWithRequestBuilder(inboxId: inboxId, page: page, searchFilter: searchFilter, size: size, sort: sort, unreadOnly: unreadOnly).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all emails in all inboxes in paginated form. Email API list all.
     - GET /emails
     - By default returns all emails across all inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter inboxId: (query) Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
     - parameter page: (query) Optional page index in email list pagination (optional, default to 0)
     - parameter searchFilter: (query) Optional search filter. Searches email recipients, sender, subject, email address and ID. Does not search email body (optional, default to "false")
     - parameter size: (query) Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - returns: RequestBuilder<PageEmailProjection> 
     */
    open class func getEmailsPaginatedWithRequestBuilder(inboxId: [UUID]? = nil, page: Int? = nil, searchFilter: String? = nil, size: Int? = nil, sort: Sort_getEmailsPaginated? = nil, unreadOnly: Bool? = nil) -> RequestBuilder<PageEmailProjection> {
        let path = "/emails"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": inboxId?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "searchFilter": searchFilter?.encodeToJSON(),
            "size": size?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "unreadOnly": unreadOnly?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PageEmailProjection>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get latest email in all inboxes. Most recently received.
     
     - parameter inboxIds: (query) Optional set of inboxes to filter by. Only get the latest email from these inbox IDs (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Email>
     */
    open class func getLatestEmail( inboxIds: [UUID]? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Email> {
        let deferred = Promise<Email>.pending()
        getLatestEmailWithRequestBuilder(inboxIds: inboxIds).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get latest email in all inboxes. Most recently received.
     - GET /emails/latest
     - Get the newest email in all inboxes or in a passed set of inbox IDs
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter inboxIds: (query) Optional set of inboxes to filter by. Only get the latest email from these inbox IDs (optional)
     - returns: RequestBuilder<Email> 
     */
    open class func getLatestEmailWithRequestBuilder(inboxIds: [UUID]? = nil) -> RequestBuilder<Email> {
        let path = "/emails/latest"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxIds": inboxIds?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Email>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
     
     - parameter inboxId: (query) ID of the inbox you want to get the latest email from (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Email>
     */
    open class func getLatestEmailInInbox( inboxId: UUID? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Email> {
        let deferred = Promise<Email>.pending()
        getLatestEmailInInboxWithRequestBuilder(inboxId: inboxId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get latest email in an inbox. Use `WaitForController` to get emails that may not have arrived yet.
     - GET /emails/latestIn
     - Get the newest email in all inboxes or in a passed set of inbox IDs
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter inboxId: (query) ID of the inbox you want to get the latest email from (optional)
     - returns: RequestBuilder<Email> 
     */
    open class func getLatestEmailInInboxWithRequestBuilder(inboxId: UUID? = nil) -> RequestBuilder<Email> {
        let path = "/emails/latestIn"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": inboxId?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Email>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     * enum for parameter sort
     */
    public enum Sort_getOrganizationEmailsPaginated: String, CaseIterable {
        case asc = "ASC"
        case desc = "DESC"
    }

    /**
     Get all organization emails. List team or shared test email accounts
     
     - parameter inboxId: (query) Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
     - parameter page: (query) Optional page index in email list pagination (optional, default to 0)
     - parameter searchFilter: (query) Optional search filter search filter for emails. (optional)
     - parameter size: (query) Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<PageEmailProjection>
     */
    open class func getOrganizationEmailsPaginated( inboxId: [UUID]? = nil,  page: Int? = nil,  searchFilter: String? = nil,  size: Int? = nil,  sort: Sort_getOrganizationEmailsPaginated? = nil,  unreadOnly: Bool? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<PageEmailProjection> {
        let deferred = Promise<PageEmailProjection>.pending()
        getOrganizationEmailsPaginatedWithRequestBuilder(inboxId: inboxId, page: page, searchFilter: searchFilter, size: size, sort: sort, unreadOnly: unreadOnly).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get all organization emails. List team or shared test email accounts
     - GET /emails/organization
     - By default returns all emails across all team inboxes sorted by ascending created at date. Responses are paginated. You can restrict results to a list of inbox IDs. You can also filter out read messages
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter inboxId: (query) Optional inbox ids to filter by. Can be repeated. By default will use all inboxes belonging to your account. (optional)
     - parameter page: (query) Optional page index in email list pagination (optional, default to 0)
     - parameter searchFilter: (query) Optional search filter search filter for emails. (optional)
     - parameter size: (query) Optional page size in email list pagination. Maximum size is 100. Use page index and sort to page through larger results (optional, default to 20)
     - parameter sort: (query) Optional createdAt sort direction ASC or DESC (optional, default to .asc)
     - parameter unreadOnly: (query) Optional filter for unread emails only. All emails are considered unread until they are viewed in the dashboard or requested directly (optional, default to false)
     - returns: RequestBuilder<PageEmailProjection> 
     */
    open class func getOrganizationEmailsPaginatedWithRequestBuilder(inboxId: [UUID]? = nil, page: Int? = nil, searchFilter: String? = nil, size: Int? = nil, sort: Sort_getOrganizationEmailsPaginated? = nil, unreadOnly: Bool? = nil) -> RequestBuilder<PageEmailProjection> {
        let path = "/emails/organization"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": inboxId?.encodeToJSON(),
            "page": page?.encodeToJSON(),
            "searchFilter": searchFilter?.encodeToJSON(),
            "size": size?.encodeToJSON(),
            "sort": sort?.encodeToJSON(),
            "unreadOnly": unreadOnly?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<PageEmailProjection>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get raw email string. Returns unparsed raw SMTP message with headers and body.
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<String>
     */
    open class func getRawEmailContents( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<String> {
        let deferred = Promise<String>.pending()
        getRawEmailContentsWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get raw email string. Returns unparsed raw SMTP message with headers and body.
     - GET /emails/{emailId}/raw
     - Returns a raw, unparsed, and unprocessed email. If your client has issues processing the response it is likely due to the response content-type which is text/plain. If you need a JSON response content-type use the getRawEmailJson endpoint
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<String> 
     */
    open class func getRawEmailContentsWithRequestBuilder(emailId: UUID) -> RequestBuilder<String> {
        var path = "/emails/{emailId}/raw"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<String>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<RawEmailJson>
     */
    open class func getRawEmailJson( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<RawEmailJson> {
        let deferred = Promise<RawEmailJson>.pending()
        getRawEmailJsonWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get raw email in JSON. Unparsed SMTP message in JSON wrapper format.
     - GET /emails/{emailId}/raw/json
     - Returns a raw, unparsed, and unprocessed email wrapped in a JSON response object for easier handling when compared with the getRawEmail text/plain response
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<RawEmailJson> 
     */
    open class func getRawEmailJsonWithRequestBuilder(emailId: UUID) -> RequestBuilder<RawEmailJson> {
        var path = "/emails/{emailId}/raw/json"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<RawEmailJson>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Get unread email count
     
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<UnreadCount>
     */
    open class func getUnreadEmailCount(apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<UnreadCount> {
        let deferred = Promise<UnreadCount>.pending()
        getUnreadEmailCountWithRequestBuilder().execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Get unread email count
     - GET /emails/unreadCount
     - Get number of emails unread. Unread means has not been viewed in dashboard or returned in an email API response
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - returns: RequestBuilder<UnreadCount> 
     */
    open class func getUnreadEmailCountWithRequestBuilder() -> RequestBuilder<UnreadCount> {
        let path = "/emails/unreadCount"
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<UnreadCount>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "GET", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Reply to an email
     
     - parameter emailId: (path) ID of the email that should be replied to 
     - parameter replyToEmailOptions: (body) replyToEmailOptions 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<SentEmailDto>
     */
    open class func replyToEmail( emailId: UUID,  replyToEmailOptions: ReplyToEmailOptions, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<SentEmailDto> {
        let deferred = Promise<SentEmailDto>.pending()
        replyToEmailWithRequestBuilder(emailId: emailId, replyToEmailOptions: replyToEmailOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Reply to an email
     - PUT /emails/{emailId}
     - Send the reply to the email sender or reply-to and include same subject cc bcc etc. Reply to an email and the contents will be sent with the existing subject to the emails `to`, `cc`, and `bcc`.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of the email that should be replied to 
     - parameter replyToEmailOptions: (body) replyToEmailOptions 
     - returns: RequestBuilder<SentEmailDto> 
     */
    open class func replyToEmailWithRequestBuilder(emailId: UUID, replyToEmailOptions: ReplyToEmailOptions) -> RequestBuilder<SentEmailDto> {
        var path = "/emails/{emailId}"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: replyToEmailOptions)

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<SentEmailDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "PUT", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Send email
     
     - parameter inboxId: (query) ID of the inbox you want to send the email from (optional)
     - parameter useDomainPool: (query) Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)
     - parameter sendEmailOptions: (body) Options for the email (optional)
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<Void>
     */
    open class func sendEmailSourceOptional( inboxId: UUID? = nil,  useDomainPool: Bool? = nil,  sendEmailOptions: SendEmailOptions? = nil, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<Void> {
        let deferred = Promise<Void>.pending()
        sendEmailSourceOptionalWithRequestBuilder(inboxId: inboxId, useDomainPool: useDomainPool, sendEmailOptions: sendEmailOptions).execute(apiResponseQueue) { result -> Void in
            switch result {
            case .success:
                deferred.resolver.fulfill(())
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Send email
     - POST /emails
     - Alias for `InboxController.sendEmail` method - see original method for full details. Sends an email from a given inbox that you have created. If no inbox is supplied a random inbox will be created for you and used to send the email.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter inboxId: (query) ID of the inbox you want to send the email from (optional)
     - parameter useDomainPool: (query) Use domain pool. Optionally create inbox to send from using the mailslurp domain pool. (optional)
     - parameter sendEmailOptions: (body) Options for the email (optional)
     - returns: RequestBuilder<Void> 
     */
    open class func sendEmailSourceOptionalWithRequestBuilder(inboxId: UUID? = nil, useDomainPool: Bool? = nil, sendEmailOptions: SendEmailOptions? = nil) -> RequestBuilder<Void> {
        let path = "/emails"
        let URLString = mailslurpAPI.basePath + path
        let parameters = JSONEncodingHelper.encodingParameters(forEncodableObject: sendEmailOptions)

        var urlComponents = URLComponents(string: URLString)
        urlComponents?.queryItems = APIHelper.mapValuesToQueryItems([
            "inboxId": inboxId?.encodeToJSON(),
            "useDomainPool": useDomainPool?.encodeToJSON(),
        ])

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<Void>.Type = mailslurpAPI.requestBuilderFactory.getNonDecodableBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

    /**
     Validate email HTML contents
     
     - parameter emailId: (path) ID of email 
     - parameter apiResponseQueue: The queue on which api response is dispatched.
     - returns: Promise<ValidationDto>
     */
    open class func validateEmail( emailId: UUID, apiResponseQueue: DispatchQueue = mailslurpAPI.apiResponseQueue) -> Promise<ValidationDto> {
        let deferred = Promise<ValidationDto>.pending()
        validateEmailWithRequestBuilder(emailId: emailId).execute(apiResponseQueue) { result -> Void in
            switch result {
            case let .success(response):
                deferred.resolver.fulfill(response.body!)
            case let .failure(error):
                deferred.resolver.reject(error)
            }
        }
        return deferred.promise
    }

    /**
     Validate email HTML contents
     - POST /emails/{emailId}/validate
     - Validate the HTML content of email if HTML is found. Considered valid if no HTML is present.
     - API Key:
       - type: apiKey x-api-key 
       - name: API_KEY
     - parameter emailId: (path) ID of email 
     - returns: RequestBuilder<ValidationDto> 
     */
    open class func validateEmailWithRequestBuilder(emailId: UUID) -> RequestBuilder<ValidationDto> {
        var path = "/emails/{emailId}/validate"
        let emailIdPreEscape = "\(APIHelper.mapValueToPathItem(emailId))"
        let emailIdPostEscape = emailIdPreEscape.addingPercentEncoding(withAllowedCharacters: .urlPathAllowed) ?? ""
        path = path.replacingOccurrences(of: "{emailId}", with: emailIdPostEscape, options: .literal, range: nil)
        let URLString = mailslurpAPI.basePath + path
        let parameters: [String: Any]? = nil

        let urlComponents = URLComponents(string: URLString)

        let nillableHeaders: [String: Any?] = [
            :
        ]

        let headerParameters = APIHelper.rejectNilHeaders(nillableHeaders)

        let requestBuilder: RequestBuilder<ValidationDto>.Type = mailslurpAPI.requestBuilderFactory.getBuilder()

        return requestBuilder.init(method: "POST", URLString: (urlComponents?.string ?? URLString), parameters: parameters, headers: headerParameters)
    }

}
