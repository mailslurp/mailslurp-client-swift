//
// EmailPreview.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable
import AnyCodable

/** Preview of an email message. For full message (including body and attachments) call the &#x60;getEmail&#x60; or other email endpoints with the provided email ID. */
@objc public class EmailPreview: NSObject, Codable {

    /** List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension. */
    public var attachments: [String]?
    /** List of &#x60;BCC&#x60; recipients email addresses that the email was addressed to. See recipients object for names. */
    public var bcc: [String]?
    /** List of &#x60;CC&#x60; recipients email addresses that the email was addressed to. See recipients object for names. */
    public var cc: [String]?
    /** When was the email received by MailSlurp */
    public var createdAt: Date?
    /** Who the email was sent from. An email address - see fromName for the sender name. */
    public var from: String?
    /** ID of the email entity */
    public var _id: UUID?
    /** Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks. */
    public var read: Bool?
    public var readNum: NSNumber? {
        get {
            return read as NSNumber?
        }
    }
    /** The subject line of the email message as specified by SMTP subject header */
    public var subject: String?
    /** List of &#x60;To&#x60; recipient email addresses that the email was addressed to. See recipients object for names. */
    public var to: [String]?

    public init(attachments: [String]? = nil, bcc: [String]? = nil, cc: [String]? = nil, createdAt: Date? = nil, from: String? = nil, _id: UUID? = nil, read: Bool? = nil, subject: String? = nil, to: [String]? = nil) {
        self.attachments = attachments
        self.bcc = bcc
        self.cc = cc
        self.createdAt = createdAt
        self.from = from
        self._id = _id
        self.read = read
        self.subject = subject
        self.to = to
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case attachments
        case bcc
        case cc
        case createdAt
        case from
        case _id = "id"
        case read
        case subject
        case to
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(attachments, forKey: .attachments)
        try container.encodeIfPresent(bcc, forKey: .bcc)
        try container.encodeIfPresent(cc, forKey: .cc)
        try container.encodeIfPresent(createdAt, forKey: .createdAt)
        try container.encodeIfPresent(from, forKey: .from)
        try container.encodeIfPresent(_id, forKey: ._id)
        try container.encodeIfPresent(read, forKey: .read)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encodeIfPresent(to, forKey: .to)
    }



}
