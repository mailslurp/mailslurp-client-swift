//
// WebhookResultDto.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable
import AnyCodable

@objc public class WebhookResultDto: NSObject, Codable {

    public enum HttpMethod: String, Codable, CaseIterable {
        case _get = "GET"
        case head = "HEAD"
        case post = "POST"
        case put = "PUT"
        case patch = "PATCH"
        case delete = "DELETE"
        case options = "OPTIONS"
        case trace = "TRACE"
    }
    public enum ResultType: String, Codable, CaseIterable {
        case badResponse = "BAD_RESPONSE"
        case exception = "EXCEPTION"
        case success = "SUCCESS"
    }
    public enum WebhookEvent: String, Codable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
    }
    public var createdAt: Date
    public var httpMethod: HttpMethod
    public var _id: UUID?
    public var inboxId: UUID
    public var messageId: String
    public var redriveId: UUID?
    public var responseBodyExtract: String?
    public var responseStatus: Int?
    public var responseStatusNum: NSNumber? {
        get {
            return responseStatus as NSNumber?
        }
    }
    public var responseTimeMillis: Int64
    public var resultType: ResultType?
    public var updatedAt: Date
    public var userId: UUID
    public var webhookEvent: WebhookEvent
    public var webhookId: UUID
    public var webhookUrl: String

    public init(createdAt: Date, httpMethod: HttpMethod, _id: UUID? = nil, inboxId: UUID, messageId: String, redriveId: UUID? = nil, responseBodyExtract: String? = nil, responseStatus: Int? = nil, responseTimeMillis: Int64, resultType: ResultType? = nil, updatedAt: Date, userId: UUID, webhookEvent: WebhookEvent, webhookId: UUID, webhookUrl: String) {
        self.createdAt = createdAt
        self.httpMethod = httpMethod
        self._id = _id
        self.inboxId = inboxId
        self.messageId = messageId
        self.redriveId = redriveId
        self.responseBodyExtract = responseBodyExtract
        self.responseStatus = responseStatus
        self.responseTimeMillis = responseTimeMillis
        self.resultType = resultType
        self.updatedAt = updatedAt
        self.userId = userId
        self.webhookEvent = webhookEvent
        self.webhookId = webhookId
        self.webhookUrl = webhookUrl
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case createdAt
        case httpMethod
        case _id = "id"
        case inboxId
        case messageId
        case redriveId
        case responseBodyExtract
        case responseStatus
        case responseTimeMillis
        case resultType
        case updatedAt
        case userId
        case webhookEvent
        case webhookId
        case webhookUrl
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(httpMethod, forKey: .httpMethod)
        try container.encodeIfPresent(_id, forKey: ._id)
        try container.encode(inboxId, forKey: .inboxId)
        try container.encode(messageId, forKey: .messageId)
        try container.encodeIfPresent(redriveId, forKey: .redriveId)
        try container.encodeIfPresent(responseBodyExtract, forKey: .responseBodyExtract)
        try container.encodeIfPresent(responseStatus, forKey: .responseStatus)
        try container.encode(responseTimeMillis, forKey: .responseTimeMillis)
        try container.encodeIfPresent(resultType, forKey: .resultType)
        try container.encode(updatedAt, forKey: .updatedAt)
        try container.encode(userId, forKey: .userId)
        try container.encode(webhookEvent, forKey: .webhookEvent)
        try container.encode(webhookId, forKey: .webhookId)
        try container.encode(webhookUrl, forKey: .webhookUrl)
    }



}
