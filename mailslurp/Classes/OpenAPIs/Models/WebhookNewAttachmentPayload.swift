//
// WebhookNewAttachmentPayload.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation
import AnyCodable
import AnyCodable

/** NEW_ATTACHMENT webhook payload. Sent to your webhook url endpoint via HTTP POST when an email is received by the inbox that your webhook is attached to that contains an attachment. You can use the attachmentId to download the attachment. */
@objc public class WebhookNewAttachmentPayload: NSObject, Codable {

    public enum EventName: String, Codable, CaseIterable {
        case emailReceived = "EMAIL_RECEIVED"
        case newEmail = "NEW_EMAIL"
        case newContact = "NEW_CONTACT"
        case newAttachment = "NEW_ATTACHMENT"
        case emailOpened = "EMAIL_OPENED"
        case emailRead = "EMAIL_READ"
    }
    /** ID of attachment. Use the &#x60;AttachmentController&#x60; to */
    public var attachmentId: String?
    /** Size of attachment in bytes */
    public var contentLength: Int64?
    public var contentLengthNum: NSNumber? {
        get {
            return contentLength as NSNumber?
        }
    }
    /** Content type of attachment such as &#39;image/png&#39; or &#39;application/pdf */
    public var contentType: String?
    /** Name of the event type webhook is being triggered for. */
    public var eventName: EventName?
    /** Idempotent message ID. Store this ID locally or in a database to prevent message duplication. */
    public var messageId: String?
    /** Filename of the attachment if present */
    public var name: String?
    /** ID of webhook entity being triggered */
    public var webhookId: UUID?
    /** Name of the webhook being triggered */
    public var webhookName: String?

    public init(attachmentId: String? = nil, contentLength: Int64? = nil, contentType: String? = nil, eventName: EventName? = nil, messageId: String? = nil, name: String? = nil, webhookId: UUID? = nil, webhookName: String? = nil) {
        self.attachmentId = attachmentId
        self.contentLength = contentLength
        self.contentType = contentType
        self.eventName = eventName
        self.messageId = messageId
        self.name = name
        self.webhookId = webhookId
        self.webhookName = webhookName
    }
    public enum CodingKeys: String, CodingKey, CaseIterable {
        case attachmentId
        case contentLength
        case contentType
        case eventName
        case messageId
        case name
        case webhookId
        case webhookName
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(attachmentId, forKey: .attachmentId)
        try container.encodeIfPresent(contentLength, forKey: .contentLength)
        try container.encodeIfPresent(contentType, forKey: .contentType)
        try container.encodeIfPresent(eventName, forKey: .eventName)
        try container.encodeIfPresent(messageId, forKey: .messageId)
        try container.encodeIfPresent(name, forKey: .name)
        try container.encodeIfPresent(webhookId, forKey: .webhookId)
        try container.encodeIfPresent(webhookName, forKey: .webhookName)
    }



}
