//
// EmailPreview.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** Preview of an email message. For full message (including body and attachments) call the `getEmail` or other email endpoints with the provided email ID. */
@objcMembers public class EmailPreview: NSObject, Codable, ParameterConvertible {

    /** ID of the email entity */
    public var _id: UUID
    /** ID of the inbox that received the email */
    public var inboxId: UUID?
    /** ID of the domain that received the email */
    public var domainId: UUID?
    /** The subject line of the email message as specified by SMTP subject header */
    public var subject: String?
    /** List of `To` recipient email addresses that the email was addressed to. See recipients object for names. */
    public var to: [String]?
    /** Who the email was sent from. An email address - see fromName for the sender name. */
    public var from: String?
    /** List of `BCC` recipients email addresses that the email was addressed to. See recipients object for names. */
    public var bcc: [String]?
    /** List of `CC` recipients email addresses that the email was addressed to. See recipients object for names. */
    public var cc: [String]?
    /** When was the email received by MailSlurp */
    public var createdAt: Date
    /** Read flag. Has the email ever been viewed in the dashboard or fetched via the API with a hydrated body? If so the email is marked as read. Paginated results do not affect read status. Read status is different to email opened event as it depends on your own account accessing the email. Email opened is determined by tracking pixels sent to other uses if enable during sending. You can listened for both email read and email opened events using webhooks. */
    public var read: Bool
    /** List of IDs of attachments found in the email. Use these IDs with the Inbox and Email Controllers to download attachments and attachment meta data such as filesize, name, extension. */
    public var attachments: [String]?
    /** MailSlurp thread ID for email chain that enables lookup for In-Reply-To and References fields. */
    public var threadId: UUID?
    /** RFC 5322 Message-ID header value without angle brackets. */
    public var messageId: String?
    /** Parsed value of In-Reply-To header. A Message-ID in a thread. */
    public var inReplyTo: String?
    public var sender: Sender?
    public var recipients: EmailRecipients?
    public var favourite: Bool?
    public var favouriteNum: NSNumber? {
        get {
            return favourite as NSNumber?
        }
    }
    public var bodyPartContentTypes: [String]?
    public var plusAddress: UUID?
    public var sizeBytes: Int64?
    public var sizeBytesNum: NSNumber? {
        get {
            return sizeBytes as NSNumber?
        }
    }

    public init(_id: UUID, inboxId: UUID? = nil, domainId: UUID? = nil, subject: String? = nil, to: [String]?, from: String? = nil, bcc: [String]? = nil, cc: [String]? = nil, createdAt: Date, read: Bool, attachments: [String]? = nil, threadId: UUID? = nil, messageId: String? = nil, inReplyTo: String? = nil, sender: Sender? = nil, recipients: EmailRecipients? = nil, favourite: Bool? = nil, bodyPartContentTypes: [String]? = nil, plusAddress: UUID? = nil, sizeBytes: Int64? = nil) {
        self._id = _id
        self.inboxId = inboxId
        self.domainId = domainId
        self.subject = subject
        self.to = to
        self.from = from
        self.bcc = bcc
        self.cc = cc
        self.createdAt = createdAt
        self.read = read
        self.attachments = attachments
        self.threadId = threadId
        self.messageId = messageId
        self.inReplyTo = inReplyTo
        self.sender = sender
        self.recipients = recipients
        self.favourite = favourite
        self.bodyPartContentTypes = bodyPartContentTypes
        self.plusAddress = plusAddress
        self.sizeBytes = sizeBytes
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case _id = "id"
        case inboxId
        case domainId
        case subject
        case to
        case from
        case bcc
        case cc
        case createdAt
        case read
        case attachments
        case threadId
        case messageId
        case inReplyTo
        case sender
        case recipients
        case favourite
        case bodyPartContentTypes
        case plusAddress
        case sizeBytes
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(_id, forKey: ._id)
        try container.encodeIfPresent(inboxId, forKey: .inboxId)
        try container.encodeIfPresent(domainId, forKey: .domainId)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encode(to, forKey: .to)
        try container.encodeIfPresent(from, forKey: .from)
        try container.encodeIfPresent(bcc, forKey: .bcc)
        try container.encodeIfPresent(cc, forKey: .cc)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(read, forKey: .read)
        try container.encodeIfPresent(attachments, forKey: .attachments)
        try container.encodeIfPresent(threadId, forKey: .threadId)
        try container.encodeIfPresent(messageId, forKey: .messageId)
        try container.encodeIfPresent(inReplyTo, forKey: .inReplyTo)
        try container.encodeIfPresent(sender, forKey: .sender)
        try container.encodeIfPresent(recipients, forKey: .recipients)
        try container.encodeIfPresent(favourite, forKey: .favourite)
        try container.encodeIfPresent(bodyPartContentTypes, forKey: .bodyPartContentTypes)
        try container.encodeIfPresent(plusAddress, forKey: .plusAddress)
        try container.encodeIfPresent(sizeBytes, forKey: .sizeBytes)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension EmailPreview: Identifiable {}
