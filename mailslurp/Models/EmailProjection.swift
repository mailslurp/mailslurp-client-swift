//
// EmailProjection.swift
//
// Generated by openapi-generator
// https://openapi-generator.tech
//

import Foundation

/** A compact representation of a full email. Used in list endpoints to keep response sizes low. Body and attachments are not included. To get all fields of the email use the `getEmail` method with the email projection&#39;s ID. See `EmailDto` for documentation on projection properties. */
@objcMembers public class EmailProjection: NSObject, Codable, ParameterConvertible {

    public var subject: String?
    public var sender: Sender?
    public var recipients: EmailRecipients?
    public var attachments: [String]?
    public var inboxId: UUID
    public var createdAt: Date
    public var to: [String]
    public var cc: [String]?
    public var bcc: [String]?
    public var messageId: String?
    public var domainId: UUID?
    public var favourite: Bool?
    public var favouriteNum: NSNumber? {
        get {
            return favourite as NSNumber?
        }
    }
    public var plusAddress: UUID?
    public var sizeBytes: Int64?
    public var sizeBytesNum: NSNumber? {
        get {
            return sizeBytes as NSNumber?
        }
    }
    public var inReplyTo: String?
    public var read: Bool
    public var bodyExcerpt: String?
    public var textExcerpt: String?
    public var bodyPartContentTypes: [String]?
    public var bodyMD5Hash: String?
    public var teamAccess: Bool
    public var _id: UUID
    public var threadId: UUID?
    public var from: String?

    public init(subject: String? = nil, sender: Sender? = nil, recipients: EmailRecipients? = nil, attachments: [String]? = nil, inboxId: UUID, createdAt: Date, to: [String], cc: [String]? = nil, bcc: [String]? = nil, messageId: String? = nil, domainId: UUID? = nil, favourite: Bool? = nil, plusAddress: UUID? = nil, sizeBytes: Int64? = nil, inReplyTo: String? = nil, read: Bool, bodyExcerpt: String? = nil, textExcerpt: String? = nil, bodyPartContentTypes: [String]? = nil, bodyMD5Hash: String? = nil, teamAccess: Bool, _id: UUID, threadId: UUID? = nil, from: String?) {
        self.subject = subject
        self.sender = sender
        self.recipients = recipients
        self.attachments = attachments
        self.inboxId = inboxId
        self.createdAt = createdAt
        self.to = to
        self.cc = cc
        self.bcc = bcc
        self.messageId = messageId
        self.domainId = domainId
        self.favourite = favourite
        self.plusAddress = plusAddress
        self.sizeBytes = sizeBytes
        self.inReplyTo = inReplyTo
        self.read = read
        self.bodyExcerpt = bodyExcerpt
        self.textExcerpt = textExcerpt
        self.bodyPartContentTypes = bodyPartContentTypes
        self.bodyMD5Hash = bodyMD5Hash
        self.teamAccess = teamAccess
        self._id = _id
        self.threadId = threadId
        self.from = from
    }

    public enum CodingKeys: String, CodingKey, CaseIterable {
        case subject
        case sender
        case recipients
        case attachments
        case inboxId
        case createdAt
        case to
        case cc
        case bcc
        case messageId
        case domainId
        case favourite
        case plusAddress
        case sizeBytes
        case inReplyTo
        case read
        case bodyExcerpt
        case textExcerpt
        case bodyPartContentTypes
        case bodyMD5Hash
        case teamAccess
        case _id = "id"
        case threadId
        case from
    }

    // Encodable protocol methods

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encodeIfPresent(subject, forKey: .subject)
        try container.encodeIfPresent(sender, forKey: .sender)
        try container.encodeIfPresent(recipients, forKey: .recipients)
        try container.encodeIfPresent(attachments, forKey: .attachments)
        try container.encode(inboxId, forKey: .inboxId)
        try container.encode(createdAt, forKey: .createdAt)
        try container.encode(to, forKey: .to)
        try container.encodeIfPresent(cc, forKey: .cc)
        try container.encodeIfPresent(bcc, forKey: .bcc)
        try container.encodeIfPresent(messageId, forKey: .messageId)
        try container.encodeIfPresent(domainId, forKey: .domainId)
        try container.encodeIfPresent(favourite, forKey: .favourite)
        try container.encodeIfPresent(plusAddress, forKey: .plusAddress)
        try container.encodeIfPresent(sizeBytes, forKey: .sizeBytes)
        try container.encodeIfPresent(inReplyTo, forKey: .inReplyTo)
        try container.encode(read, forKey: .read)
        try container.encodeIfPresent(bodyExcerpt, forKey: .bodyExcerpt)
        try container.encodeIfPresent(textExcerpt, forKey: .textExcerpt)
        try container.encodeIfPresent(bodyPartContentTypes, forKey: .bodyPartContentTypes)
        try container.encodeIfPresent(bodyMD5Hash, forKey: .bodyMD5Hash)
        try container.encode(teamAccess, forKey: .teamAccess)
        try container.encode(_id, forKey: ._id)
        try container.encodeIfPresent(threadId, forKey: .threadId)
        try container.encode(from, forKey: .from)
    }
}


@available(iOS 13, tvOS 13, watchOS 6, macOS 10.15, *)
extension EmailProjection: Identifiable {}
